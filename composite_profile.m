% This function draws the composition profile for all species in the
% polymer system onto the same plot, with distinct colorbars for each
% species.

function composite_profile(R,x,y,z,options)
    %% Define all input variables and name/value pair options:
    arguments
        
        % The first parameter of this function, R, is "overloaded". This
        % means that the function accepts either a string or a data array 
        % for the first parameter, and it will work correctly either way. 
        
        % If the first parameter is a string, we assume it is a filename
        % that contains the data we wish to plot. Thus, we will use
        % read_rgrid.m to collect the data that will be plotted.
        
        % If the first parameter is instead a data array, it must contain
        % all of the composition data stored in the rgrid file. For an
        % N-dimensional system, R must be an (N+1)-dimensional array. In
        % 3D, R(i,j,k,l) gives the composition of species l at gridpoint
        % (i,j,k). 
        R
        
        % If R is a data array, then the real-space coordinates
        % corresponding to those data must be provided as well. For a 2D
        % system, x and y are needed, while z is also needed in 3D. For a
        % system discretized into an i x j x k grid, these arrays must
        % have size (i,j,k), where x(i,j,k) corresponds to the x-coordinate
        % of the data points in R(i,j,k,:), and so on for y and z.
        
        % x and y are only made optional to allow for the user to run
        % individual_profiles(filename) without causing an error.
        % If the first input parameter is a filename (a string), x, y, and 
        % z are deleted and regenerated by the function read_rgrid.
        % However, if R is a data array and x and y are not provided, an
        % error will occur.
        x = []
        y = []
        z = []
        
        % ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        % The rest of the inputs are optional name-value pair inputs:

        % savefile is a filename to which the figures will be saved.
        % The file extension provided (e.g. ".fig" or ".png") will be used
        % to determine the type of file to save. Since this function
        % typically generates more than 1 figure, we append mono_label(i)
        % to the end of the filename when saving the composition profile
        % for species i. If left empty (which is the default behavior), the
        % figures are not saved.
        options.savefile = "";
        
        % species is an array that contains the indices for each monomer
        % species to plot. So, if the data set contains 4 species but only
        % the first and third should be plotted, species = [1,3]. The
        % default behavior is to plot all species.
        options.species;

        % fontsize specifies the FontSize parameter for the axis on which
        % data are plotted. Default value is 14.
        options.fontsize = 14;
        
        % hex3 is a boolean indicating whether to plot 3 unit cells for a
        % hexagonal system rather than 1. 
        options.hex3 = false
        
        % isovalue is an array of isovalues representing the minimum volume
        % fraction to show on plot. One for each species. If not specified,
        % we call get_isovalues.m to calculate them automatically.
        options.isovalue
        
        % mono_label contains labels for each monomer species. If not
        % specified, we use ["A","B","C",...] as the default behavior.
        options.mono_label
         
        % opacity contains values of opacity to plot for each species. 2
        % opacities are specified for each species i: opacity(1,i) is the
        % opacity of the interior of the domains, while opacity(2,i) is the
        % opacity of the exterior (caps) of the domains. If unspecified,
        % all values default to 1 (completely opaque).
        options.opacity
        
        % map is a cell array containing a colormap for each species.
        % map{i} is the colormap for species i. If unspecified, we use the
        % default colormaps generated by get_colormaps.m.
        options.map
        
        % thick is the value for "linethickness" used to draw the outer box
        % of the unit cell. Default is 1
        options.thick = 1
        
        % box_color is the value for "color" used to draw the outer box of
        % the unit cell. Default is gray.
        options.box_color = [0.5,0.5,0.5]
        
        % cb_ticks is the number of ticks on the colorbar, default is 10.
        options.cb_ticks = 10;
        
        % cb_rows defines the number of rows of colorbars that are
        % shown on the figure. For example, if there are 8 colorbars on the
        % figure, cb_rows = 2 will result in a 2x4 grid of colorbars
        % being shown on the figure, as opposed to the default 1x8 grid.
        options.cb_rows = 1;

        % n_digits is the number of digits past the decimal point to use
        % for the colorbar tick labels. Can be specified as a scalar, or as
        % an array of length n_mnr (one value per monomer species plotted)
        % if you want a different # of digits for each colorbar. Default is
        % 3.
        options.n_digits = 3;
        
    end
    
    % Ensure that the code below can access our utilities
    addpath(pwd+"/utilities")
    
    % if a filename is passed to the function, read data from that file
    if ischar(R) || isstring(R) 
        
        clear x y z; % We will determine x, y, and z from the rgrid file
        close all; % close other figures
                
        % Read data from file
        [R,x,y,z,dim,lattype,cell_d,angle,n_mnr,grid] = read_rgrid(R);
        
        % If hex3 is true, make sure system is actually hexagonal
        if options.hex3 && strcmp(lattype,'hexagonal') == 0
            error("hex3 is true but crystal system is not hexagonal")
        end
        
        % Get lattice basis vectors
        basis = get_basis(cell_d,angle);
    
    % If R is not a string defining a filename, we assume it is a data
    % array containing species compositions. So, below we make sure we have
    % all of the other data we need to proceed, and define some useful
    % variables.
    else
        
        % Make sure that we have x and y (and z if data are 3D):
        if isempty(x) || isempty(y) % if x or y are not provided
            error("Necessary coordinates of data were not provided")
        elseif ndims(x) == 3 && isempty(z) % R is 3D and z is not provided
            error("z coordinates were not provided for 3D data")
        end
        
        dim = ndims(x);
        
        % Define grid, basis, and n_mnr
        grid = [size(R,1)-1,size(R,2)-1,size(R,3)-1];
        n_mnr = size(R,4);
        basis = [x(end,1,1),y(end,1,1),z(end,1,1);
                 x(1,end,1),y(1,end,1),z(1,end,1);
                 x(1,1,end),y(1,1,end),z(1,1,end);];
        
    end
    
    % Get other parameters needed for composition profiles, using
    % default values if they are not provided as name-value inputs:
    if isfield(options,'species')
        n_mnr = length(options.species); % override n_mnr defined above
        species = options.species;
    else
        species = 1:n_mnr;
    end
    
    if isfield(options,'mono_label')
        mono_label = options.mono_label;
    else
        mono_label = char(1,n_mnr);
        for in = 1:n_mnr
            mono_label(in) = char('A'+in-1);
        end
    end
    
    if isfield(options,'opacity')
        opacity = options.opacity;
    else
        opacity = ones(2,n_mnr);
    end
    
    if isfield(options,'map')
        map = options.map;
    else
        map = get_colormaps();
    end
    
    if isfield(options,'isovalue')
        isovalue = options.isovalue;
    else
        isovalue = get_isovalues(R,dim,n_mnr,grid,'plot',false);
    end
    
    if isscalar(options.n_digits)
        n_digits = ones(1,n_mnr) * options.n_digits;
    else
        if length(options.n_digits) ~= n_mnr
            error('n_digits must be a scalar or an array of length n_mnr')
        end
        n_digits = options.n_digits;
    end
    
    hex3 = options.hex3; 
    thick = options.thick; 
    box_clr = options.box_color;
    cb_ticks = options.cb_ticks;
    savefile = options.savefile;
    fontsize = options.fontsize;
    cb_rows = options.cb_rows;
    clear options
    
    % ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    %% Create composite density profile
    
    figure(); 
    hold on; 
    set(gca,'fontsize',fontsize);
    t = title("Composite Density Profile");
    set(t,"Units","Points");
    t_size = get(t,"extent");
    % Concatenate elements of map into a single long colormap called newmap
    if size(map,1) == 1 % if map is a horizontal cell array
        newmap = cell2mat(map(1:n_mnr)');
    else % map is a vertical cell array
        newmap = cell2mat(map(1:n_mnr));
    end
    
    % Initialize variables that will be used to rescale data to our cmap
    D = zeros(size(R));
    newisovalue = zeros(1,n_mnr);
    max_comps = zeros(1,n_mnr);
    zero_val = 0;
    
    % Loop over each species to plot
    for in = species
        
        % MATLAB only allows one colormap per axis, and we want to plot all
        % of our data (each with its own colormap) on the same axis. Thus,
        % we have to use a trick. We concatenate the colormaps for each
        % species into one giant colormap, and then rescale our data to fit
        % into the colormap appropriately. Then, we can just manually fix
        % the colorbar ticklabels to indicate the correct data, rather than
        % the rescaled data.
        
        % So, below we rescale R(:,:,:,in) such that the minimum is 0 and
        % the maximum is size(map{in},1) - 1. We store this result in array
        % D, where we also add an additional constant (zero_val) to ensure
        % that none of the data range of species i overlaps with that of
        % species j, for any i ≠ j.
        
        max_comps(in) = max(R(:,:,:,in),[],'all');
        range = max_comps(in) - isovalue(in);
        cmap_size = size(map{in},1);
        
        % Rescale data and isovalue:
        D(:,:,:,in) = ((R(:,:,:,in) - isovalue(in)) * (cmap_size-1)...
                      / range) + zero_val;
        newisovalue(in) = zero_val;
        
        % Update zero_val for the next species we plot
        zero_val = zero_val + cmap_size;
        
        % Plot rescaled data for this species
        patch(isosurface(x,y,z,D(:,:,:,in),newisovalue(in)), ...
              'FaceColor',map{in}(1,:),'EdgeColor','none',...
              'FaceAlpha',opacity(1,in));
        patch(isocaps(x,y,z,D(:,:,:,in),newisovalue(in)), ...
              'FaceColor','interp','EdgeColor','none',...
              'FaceAlpha',opacity(2,in));
        
        % Set view angle
        if dim == 3
            view(3);                        %Sets the view to 3-D
        else
            view(2);                        %Sets the view to 2-D
        end
        
        
        % If hex3 == true, we plot two more unit cells rotated by 120° and
        % 240° around the z-axis, which is a common way to visualize
        % hexagonal unit cells. 
        if hex3
            
            for rotation = [120,240] % Angle of rotation, in degrees
                
                % Create rotation matrix to apply to our data coordinates
                rot_matrix = [ cosd(rotation), sind(rotation), 0;
                              -sind(rotation), cosd(rotation), 0;
                                            0,              0, 1];

                % Put x, y, and z data into a 2D array coord_set, where
                % each row represents the coordinates of one data point.
                % This allows us to apply the rotation matrix to our data
                size_grid = (grid(1)+1)*(grid(2)+1)*(grid(3)+1);
                coord_set = zeros(size_grid,3);
                counter = 0;
                for iz = 1:grid(3)+1
                    for iy = 1:grid(2)+1
                        for ix = 1:grid(1)+1
                            counter = counter +1;
                            coord_set(counter,1) = x(ix,iy,iz);
                            coord_set(counter,2) = y(ix,iy,iz);
                            coord_set(counter,3) = z(ix,iy,iz);
                        end
                    end
                end

                % Apply rotation matrix to data
                coord_set = coord_set*rot_matrix;
                
                % Put data back into 3D arrays x2, y2, and z2 for plotting
                counter = 0;
                x2 = zeros(size(x));
                y2 = zeros(size(y));
                z2 = zeros(size(z));
                for iz = 1:grid(3)+1
                    for iy = 1:grid(2)+1
                        for ix = 1:grid(1)+1
                            counter = counter +1;
                            x2(ix,iy,iz) = coord_set(counter,1) ;
                            y2(ix,iy,iz) = coord_set(counter,2) ;
                            z2(ix,iy,iz) = coord_set(counter,3) ;
                        end
                    end
                end
                clear coord_set

                % Plot the isosurface, isocaps, and unit cell outline for 
                % the rotated unit cell
                patch(isosurface(x2,y2,z2,D(:,:,:,in),newisovalue(in)), ...
                      'FaceColor',map{in}(1,:),'EdgeColor','none', ...
                      'FaceAlpha',opacity(1,in));
                patch(isocaps(x2,y2,z2,D(:,:,:,in),newisovalue(in)), ...
                      'FaceColor','interp','EdgeColor','none', ...
                      'FaceAlpha',opacity(2,in));
                
                if in == 1
                    basis_2 = basis * rot_matrix; % rotated basis vecs
                    draw_lattice(basis_2,thick,box_clr);
                end
                
            end
        end
    end
    
    % Set colormap
    colormap(newmap);
    caxis([0,size(newmap,1)-1]);
    
    % Draw box around outside of unit cell
    draw_lattice(basis,thick,box_clr)

    % Fix data aspect ratio and set axis limits to "tight" setting
    daspect([1 1 1]);  % Equates the data aspect ratio for each axis
    axis tight;        % Snaps the axis to the data set
    
    % ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    %% Create colorbars and make them look good
    ax(n_mnr+1) = gca; % Save the current axis so we can reference it
    tmp = colorbar; % Create temporary colorbar in the default position
    set(ax(n_mnr+1),"Units","Points") % Absolute units rather than reduced
    set(tmp,"Units","Points")         % Absolute units rather than reduced
    
    % Below, we find the aspect ratio of the 2D projection of our 3D plot,
    % which depends on the viewing angle. We will then set the width/height
    % of our axes object to match this aspect ratio, which allows the plot
    % to have the same height and left-edge position regardless of unit
    % cell parameters. This is explained further in the documentation.
    
    pb = pbaspect; % Plot box aspect ratio
    [az,el] = view(); % viewing angle
    aspect_ratio = get_aspect_ratio(az,el,pb); % aspect ratio of plot
    
    % Fix the axes to reflect the correct aspect ratio
    ax_pos = get(ax(n_mnr+1),"Position"); % Get current axes position
    ax_pos(3) = ax_pos(4) * aspect_ratio; % Fix aspect ratio
    if ax_pos(3) < t_size(3)
        ax_pos(3) = t_size(3);
    end
    
    set(ax(n_mnr+1),"Position",ax_pos);   % Apply adjusted axes position
    delete(tmp) % Delete the temporary colorbar that we used to move the 
                % axes leftward
    
    % Set up for the case of multiple rows of colorbars
    ncol = ceil(n_mnr/cb_rows);
    if cb_rows > 1 % If we need to calculate positions of multiple cb rows
        
        % See how tall the colorbar title is
        title1 = strcat('\phi','_',mono_label(1));
        tmp = text(0,0,0,title1,'fontsize',fontsize*1.1); % Plot the text
        set(tmp,"Units","Points");
        txt_height = get(tmp,"Extent"); % Find height of the text box
        txt_height = txt_height(4);
        delete(tmp) % Delete the temporary text we plotted
        
        % Get variables needed to determine colorbar positions
        title_h = txt_height * 1.3 + 10; % Space allocated for cb titles
        total_h = ax_pos(4); % Total height of each column
        top_pos = ax_pos(4)+ax_pos(2); % coordinate of top edge of column
        cb_space = total_h - (title_h * (cb_rows-1)); 
        rows = 1:cb_rows;
        
        % construct cb_y, a list of the y-coordinates of the colorbars in
        % each row. cb_y(r) is the y-coord of the colorbar in row r.
        cb_h = cb_space / cb_rows; % height of all colorbars
        cb_y = top_pos - (rows*cb_h) - ((rows-1)*title_h); 
        
    else % Only 1 colorbar row, use default height
        
        cb_y = ones(n_mnr,1) * ax_pos(2); % y coord of each colorbar
        cb_h = ax_pos(4); % height of each colorbar
        
    end
    
    % set x-coord of first colorbar column, 40pts right of the axes object
    cb_x = ax_pos(1)+ax_pos(3)+40; 
    
    % Loop over columns/rows of colorbars and create colorbars
    for col = 1:ncol
        txt_width = 0; % variable to help us set colorbar locations
        for row = 1:cb_rows
            
            % Monomer index for this row/column
            in = (row-1)*ncol + col; 
            
            if in <= n_mnr % If this column/row should contain a colorbar:
                
                % Colorbar data limits
                cb_start = isovalue(in);
                cb_end = max_comps(in);

                % Create cb ticklabels according to specs provided by user
                cblabel = linspace(cb_start,cb_end,cb_ticks);
                tick_format = strcat('%.',string(n_digits(in)),'f');
                cblabel = compose(tick_format,cblabel');
                l_lngth = linspace(0,1,cb_ticks);

                % Create a new invisible axes object for this colorbar
                ax(in) = axes("Units","Points");
                set(ax(in),"Visible","off","XTick",[],"YTick",[],...
                    "ZTick",[],"InnerPosition",ax_pos);

                % Assign the appropriate colormap to this axes object
                colormap(ax(in),map{in});

                % Create the colorbar
                cb = colorbar(ax(in));
                cb_pos = [cb_x,cb_y(row),22,cb_h];
                set(cb,"axislocation","out","Units","Points",...
                    "ytick",l_lngth,"ticklabels",cblabel,...
                    "fontsize",fontsize,"Position",cb_pos,"color","k");
                title1 = strcat('\phi','_',mono_label(in));
                title(cb,title1,'fontsize',fontsize*1.1);
                
                % Estimate the width of our ticklabels, and if it is larger
                % than txt_width then update txt_width
                [~,ind] = max(strlength(cblabel)); %Find longest ticklabel
                tmp = text(0,0,0,cblabel(ind),'fontsize',fontsize); 
                set(tmp,"Units","Points");
                txt_extent = get(tmp,"Extent"); % Find width of the text
                if txt_extent(3) > txt_width % Update txt_width if needed
                    txt_width = txt_extent(3);
                end
                delete(tmp) % Delete the temporary text we plotted
                
            end
        end
        
        % Update colorbar x-position for the next row
        cb_x = cb_x + 22 + txt_width + 20; 
        
    end
    
    % Update figure size to show everything we want to show
    set(gcf,'Units','Points');
    fig_pos = get(gcf,'position');
    fig_pos(3) = cb_x * 1.05; % Make figure wide enough to see all cbs
    % Make figure taller to fit cb titles
    fig_pos(4) = fig_pos(4) + (fontsize*1.1); 
    set(gcf,'position',fig_pos);
    
    % Save figure if a filename is provided
    if savefile ~= ""
        saveas(gcf,savefile);
    end
    
    % Finish up
    rotate3d on
    set(gcf,'currentaxes',ax(n_mnr+1))
    hold off
    
end