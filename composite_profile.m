% This function draws the composition profile for all species in the
% polymer system onto the same plot, with distinct colorbars for each
% species.

function composite_profile(R,x,y,z,dim,options)
    %% Define all input variables and name/value pair options:

    arguments
        
        % The first parameter of this function, R, is "overloaded". This
        % means that the function accepts either a string or a data array 
        % for the first parameter, and it will work correctly either way. 
        
        % If the first parameter is a string, we assume it is a filename
        % that contains the data we wish to plot. Thus, we will use
        % read_rgrid.m to collect the data that will be plotted.
        
        % If the first parameter is instead a data array, it must contain
        % all of the composition data stored in the rgrid file. For an
        % N-dimensional system, R must be an (N+1)-dimensional array. In
        % 3D, R(i,j,k,l) gives the composition of species l at gridpoint
        % (i,j,k). 
        R
        
        % If R is a data array, then the real-space coordinates
        % corresponding to those data must be provided as well. For a 2D
        % system, x and y are needed, while z is also needed in 3D. For a
        % system discretized into an i x j x k grid, these arrays must
        % have size (i,j,k), where x(i,j,k) corresponds to the x-coordinate
        % of the data points in R(i,j,k,:), and so on for y and z.
        
        % x and y are only made optional to allow for the user to run
        % individual_profiles(filename) without causing an error.
        % If the first input parameter is a filename (a string), x, y, and 
        % z are deleted and regenerated by the function read_rgrid.
        % However, if R is a data array and x and y are not provided, an
        % error will occur.
        x = []
        y = []
        z = []
        dim = 0
        
        % ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        % The rest of the inputs are optional name-value pair inputs:

        % savefile is a filename to which the figures will be saved.
        % The file extension provided (e.g. ".fig" or ".png") will be used
        % to determine the type of file to save. Since this function
        % typically generates more than 1 figure, we append mono_label(i)
        % to the end of the filename when saving the composition profile
        % for species i. If left empty (which is the default behavior), the
        % figures are not saved.
        options.savefile = "";

        % resolution is a number that specifies the resolution of the
        % figure that is saved (if options.savefile is specified), in dots
        % per inch (dpi). Default value is 300. If set to 0, file is saved
        % at screen resolution.
        options.resolution = 300;
        
        % species is an array that contains the indices for each monomer
        % species to plot. So, if the data set contains 4 species but only
        % the first and third should be plotted, species = [1,3]. The
        % default behavior is to plot all species.
        options.species;

        % fontsize specifies the FontSize parameter for the axis on which
        % data are plotted. Default value is 14.
        options.fontsize = 14;
        
        % hex3 is a boolean indicating whether to plot 3 unit cells for a
        % hexagonal system rather than 1. 
        options.hex3 = false;

        % light is a boolean indicating whether to insert a "light" object
        % into the plot (adds shadows that can make 3d structure clearer,
        % but invalidates the accuracy of the colorbar).
        options.light = false;

        % view is a 1, 2, or 3-element vector that specifies the viewing
        % angle of the figure. If this is included, we call 
        % view(options.view) to set the viewing angle, so options.view must
        % be something that complies with the view() function. If view = 2
        % or view = 3, the view will be the default 2D or 3D view,
        % respectively. If view is a 2-element vector, the two elements
        % correspond to the azimuth and elevation angles, respectively. If
        % view is a 3-element vector, the values represent a vector that
        % points from the origin to the viewer. 
        options.view;

        % If hide_axes is set to true, the plot will not contain the tick 
        % marks, title, etc. by setting the "visible" property of the axes
        % to "off".
        options.hide_axes = false;
        
        % isovalue is an array of isovalues representing the minimum volume
        % fraction to show on plot. One for each species. If not specified,
        % we call get_isovalues.m to calculate them automatically.
        options.isovalue
        
        % mono_label contains labels for each monomer species. If not
        % specified, we use ["A","B","C",...] as the default behavior.
        options.mono_label
         
        % opacity contains values of opacity to plot for each species. 2
        % opacities are specified for each species i: opacity(1,i) is the
        % opacity of the interior of the domains, while opacity(2,i) is the
        % opacity of the exterior (caps) of the domains. If unspecified,
        % all values default to 1 (completely opaque).
        options.opacity
        
        % map is a cell array containing a colormap for each species.
        % map{i} is the colormap for species i. If unspecified, we use the
        % default colormaps generated by get_colormaps.m.
        options.map
        
        % line_width is the value for "LineWidth" used to draw the outer 
        % box of the unit cell. Default is 1
        options.line_width = 1
        
        % line_color is the value for "EdgeColor" used to draw the outer
        % box of the unit cell. Default is gray. Can be a color string as
        % well, as long as Matlab can interpret it properly as a color,
        % e.g. "y", "yellow", or "#FFFF00" (hexadecimal color code).
        options.line_color = [0.5,0.5,0.5]

        % alim, blim, and clim are 2-element arrays specifying the upper 
        % and lower limits of the region to plot in the 3D composition
        % profiles, in reduced coordinates. Default value is [0,1] for
        % each, which plots a single unit cell. If, say, alim = [0,2], then
        % the profiles will show 2 unit cells along the direction of the 
        % lattice basis vector a.
        options.alim = [0,1];
        options.blim = [0,1];
        options.clim = [0,1];
        
        % cb_ticks is the number of ticks on the colorbar, default is 10.
        options.cb_ticks = 10;
        
        % cb_rows defines the number of rows of colorbars that are
        % shown on the figure. For example, if there are 8 colorbars on the
        % figure, cb_rows = 2 will result in a 2x4 grid of colorbars
        % being shown on the figure, as opposed to the default 1x8 grid.
        options.cb_rows = 1;

        % n_digits is the number of digits past the decimal point to use
        % for the colorbar tick labels. Can be specified as a scalar, or as
        % an array of length n_mnr (one value per monomer species plotted)
        % if you want a different # of digits for each colorbar. Default is
        % 3.
        options.n_digits = 3;

        % If your SCFT result is a thin film, you should include
        % film_params as an input to apply a thin film correction.
        %
        % film_params is an array with 4 entries. The first 3 entries
        % correspond to the 3 required parameters in pscfpp that are needed
        % to define a Wall object: normalVec, interfaceThickness, and
        % wallThickness. See pscfpp documentation for details about what
        % each of these three parameters means. The fourth entry is a
        % boolean (i.e. 0 for false, 1 for true) that indicates whether or
        % not to rotate the figure to make the z axis orthogonal to the
        % wall. If this film_params input is included, the code will apply
        % a correction to the plot to make the figure look good as a thin
        % film. If it is not included, it is assumed that the data being
        % plotted are not under a thin film constraint.
        options.film_params;

        % substrate is a boolean indicating whether or not to add a box
        % in the composite profile underneath the unit cell that looks 
        % like a substrate on which the polymer rests. The box color, line
        % edge line color, and edge line width can be set by the inputs
        % substrate_color, substrate_line_color, and substrate_line_width, 
        % respectively. 
        %
        % This feature is compatible with all other features, including the
        % thin film correction. The only requirement that we enforce on the
        % other inputs is that clim(1) must be 0. 
        options.substrate = false;
        options.substrate_color = [0.5,0.5,0.5];
        options.substrate_line_color = 'k';
        options.substrate_line_width = 1;
        
        % top_wall is basically identical to substrate, except it places a
        % box on top of the unit cell rather than below it. The appearance
        % of the top_wall can be altered with top_wall_color,
        % top_wall_line_color, and top_wall_line_width. By default, these
        % appearance-related parameters are set to match the corresponding
        % parameters for the substrate.
        options.top_wall = false;
        options.top_wall_color;
        options.top_wall_line_color;
        options.top_wall_line_width;
        
    end

    %% Setup
    
    % Ensure that the code below can access our utilities
    [filepath,~,~] = fileparts(mfilename('fullpath'));
    addpath(filepath+"/utilities")
    
    % if a filename is passed to the function, read data from that file
    if ischar(R) || isstring(R) 
        
        clear x y z; % We will determine x, y, and z from the rgrid file
        close all; % close other figures
                
        % Read data from file
        [R,x,y,z,dim,lattype] = read_rgrid(R);
        
        % If hex3 is true, make sure system is actually hexagonal
        if options.hex3 && strcmp(lattype,'hexagonal') == 0
            error("hex3 is true but crystal system is not hexagonal")
        end
    
    % If R is not a string defining a filename, we assume it is a data
    % array containing species compositions. So, below we make sure we have
    % all of the other data we need to proceed, and define some useful
    % variables.
    else
        
         % Make sure that we have x, y, z, and dim:
        if isempty(x) || isempty(y) % if x or y are not provided
            error("Necessary coordinates of data were not provided")
        elseif ndims(x) == 3 && isempty(z) % R is 3D and z is not provided
            error("z coordinates were not provided for 3D data")
        elseif dim ~= 1 && dim ~= 2 && dim ~= 3
            error("dim is a required variable & must be either 1, 2, or 3")
        end

    end

    % Get n_mnr, grid, and basis from the R, x, y, and z arrays
    n_mnr = size(R,4);
    grid = size(x) - 1;
    basis = [x(end,1,1),y(end,1,1),z(end,1,1);
             x(1,end,1),y(1,end,1),z(1,end,1);
             x(1,1,end),y(1,1,end),z(1,1,end)];

    % Create figure
    fig = figure(); ax_main = axes();
    hold on; 

    % Apply thin film correction if desired
    if isfield(options,'film_params') && ~isempty(options.film_params)
        [R,x,y,z,basis] = thin_film_correction(R,x,y,z,...
                          options.film_params(1),options.film_params(2),...
                          options.film_params(3),options.film_params(4));
        grid = size(R,1:3) - 1; % Update grid
        if options.film_params(4)
            normalVec = 2; % used by change_cell_lims
        else
            normalVec = options.film_params(1); 
        end
    else
        normalVec = -1; % indicates absence of thin film correction
    end
    
    % Get other parameters needed for composition profiles, using
    % default values if they are not provided as name-value inputs:
    if isfield(options,'species')
        species = options.species;
    else
        species = 1:n_mnr;
    end
    n_species = length(species);
    
    if isfield(options,'mono_label')
        mono_label = options.mono_label;
    else
        mono_label = char(1,n_mnr);
        for in = 1:n_mnr
            mono_label(in) = char('A'+in-1);
        end
    end
    
    if isfield(options,'opacity')
        opacity = options.opacity;
    else
        opacity = ones(2,n_mnr);
    end
    
    if isfield(options,'map')
        map = options.map;
    else
        map = get_colormaps();
    end
    
    if isfield(options,'isovalue')
        isovalue = options.isovalue;
    else
        isovalue = get_isovalues(R,dim,'plot',false);
    end
    
    if isscalar(options.n_digits)
        n_digits = ones(1,n_mnr) * options.n_digits;
    else
        if length(options.n_digits) ~= n_mnr
            error('n_digits must be a scalar or an array of length n_mnr')
        end
        n_digits = options.n_digits;
    end

    if isfield(options,'view')
        view_angle = options.view;
    else
        view_angle = 3;
    end

    % If user specified plot axis limits other than [0,1], adjust
    std_lims = [0,1;0,1;0,1];
    lims = [options.alim;options.blim;options.clim];
    if ~isequal(std_lims,lims)

        % This option is not compatible with the hex3 option, so check to
        % make sure hex3 is false
        if options.hex3
            error("cannot combine alim, blim, or clim inputs with hex3")
        end

        [R,x,y,z] = change_cell_lims(R,x,y,z,'alim',options.alim, ...
                                     'blim',options.blim, ...
                                     'clim',options.clim, ...
                                     'normalVec',normalVec);
    end

    % If a substrate and/or top wall are included, draw them
    if options.substrate || options.top_wall
        if (basis(1,3) > 1e-8) || (basis(2,3) > 1e-8)
            error("a and b basis vectors must be in the x-y plane")
        end
        
        % Setup
        box_basis = zeros(3,3);
        origin = [0,0,0];
        sc = 0.05; % scale factor determining how much wider the substrate
                   % and top wall are than the actual polymer unit cell

        xd = options.alim(2)-options.alim(1);
        yd = options.blim(2)-options.blim(1);
        zd = options.clim(2)-options.clim(1);
        box_basis(1,1) = (1+sc) * ((xd * basis(1,1)) + ...
                         (yd * abs(basis(2,1)) + (zd * abs(basis(3,1)))));
        box_basis(2,2) = (1+sc) * ((xd * basis(1,2)) + ...
                         (yd * abs(basis(2,2)) + (zd * abs(basis(3,2)))));
        if normalVec == -1 % not a thin film system
            box_basis(3,3) = sc * zd * basis(3,3);
        else
            box_basis(3,3) = min(z,[],'all');
        end
        
        origin(1) = min(x,[],'all') - ((sc/2) * xd * basis(1,1));
        origin(2) = min(y,[],'all') - ((sc/2) * yd * basis(2,2));
        
        if options.substrate
            % Draw substrate graphic
            origin(3) = min(z,[],'all')  - box_basis(3,3);
            draw_box(box_basis,origin,...
                     "FaceColor",options.substrate_color,...
                     "EdgeColor",options.substrate_line_color,...
                     "LineWidth",options.substrate_line_width);
        end

        if options.top_wall
            % If style inputs are unset, make them match the substrate
            if ~isfield(options,"top_wall_color")
                options.top_wall_color = options.substrate_color;
            end
            if ~isfield(options,"top_wall_line_color")
                options.top_wall_line_color = options.substrate_line_color;
            end
            if ~isfield(options,"top_wall_line_width")
                options.top_wall_line_width = options.substrate_line_width;
            end

            % Draw top wall graphic
            origin(3) = max(z,[],'all');
            draw_box(box_basis,origin,...
                     "FaceColor",options.top_wall_color,...
                     "EdgeColor",options.top_wall_line_color,...
                     "LineWidth",options.top_wall_line_width);
        end

    end
    
    resolution = options.resolution;
    hex3 = options.hex3; 
    line_width = options.line_width; 
    line_color = options.line_color;
    cb_ticks = options.cb_ticks;
    savefile = options.savefile;
    fontsize = options.fontsize;
    cb_rows = options.cb_rows;
    light_on = options.light;
    hide_axes = options.hide_axes;
    alims = options.alim;
    blims = options.blim;
    clims = options.clim;
    substrate = options.substrate;
    clear options
    
    % ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    %% Create composite density profile

    set(ax_main,'fontsize',fontsize);
    
    % Get title position in absolute units (points)
    t = title("Composite Density Profile");
    set(t,"Units","Points");
    t_size = get(t,"extent");
    set(t,"Units","Normalized");

    % Concatenate elements of map into a single long colormap called newmap
    if size(map,1) == 1 % if map is a horizontal cell array
        newmap = cell2mat(map(1:n_mnr)');
    else % map is a vertical cell array
        newmap = cell2mat(map(1:n_mnr));
    end
    
    % Initialize variables that will be used to rescale data to our cmap
    D = zeros(size(R));
    newisovalue = zeros(1,n_mnr);
    max_comps = zeros(1,n_mnr);
    zero_val = 0;
    
    % Loop over each species to plot
    for in = 1:n_mnr
        
        % MATLAB only allows one colormap per axis, and we want to plot all
        % of our data (each with its own colormap) on the same axis. Thus,
        % we have to use a trick. We concatenate the colormaps for each
        % species into one giant colormap, and then rescale our data to fit
        % into the colormap appropriately. Then, we can just manually fix
        % the colorbar ticklabels to indicate the correct data, rather than
        % the rescaled data.
        
        % So, below we rescale R(:,:,:,in) such that the minimum is 0 and
        % the maximum is size(map{in},1) - 1. We store this result in array
        % D, where we also add an additional constant (zero_val) to ensure
        % that none of the data range of species i overlaps with that of
        % species j, for any i ≠ j.

        % ~~~~~~~~~~~~~~~~~~~~~~~~~

        % If this monomer index is not in the species array, skip to next
        % iteration of the for loop
        if ~ismember(in,species)
            continue;
        end
        
        max_comps(in) = max(R(:,:,:,in),[],'all');
        range = max_comps(in) - isovalue(in);
        cmap_size = size(map{in},1);
        
        % Rescale data and isovalue:
        D(:,:,:,in) = ((R(:,:,:,in) - isovalue(in)) * (cmap_size-1)...
                      / range) + zero_val;
        newisovalue(in) = zero_val;
        
        % Update zero_val for the next species we plot
        zero_val = zero_val + cmap_size;
        
        % Plot rescaled data for this species
        if (normalVec == -1) || ((lims(normalVec+1,1) >= 0) && ...
           (lims(normalVec+1,2) <= 1))
            
            % This should almost always be called
            patch(isosurface(x,y,z,D(:,:,:,in),newisovalue(in)),...
                  'FaceColor',map{in}(1,:),'EdgeColor','none',...
                  'FaceAlpha',opacity(1,in));
            patch(isocaps(x,y,z,D(:,:,:,in),newisovalue(in)), ...
                  'FaceColor','interp','EdgeColor','none',...
                  'FaceAlpha',opacity(2,in));

        else 
            
            % This handles the rare case in which we need to plot multiple
            % layers of a thin film, separated by empty space. 
            unit_cells = get_cell_start_points(lims(normalVec+1,:),...
                                               grid(normalVec+1)+1);
            for i = 1:(length(unit_cells)-1)
                bds = unit_cells(i):unit_cells(i+1)-1; % unit cell bounds
                if normalVec == 0
                    patch(isosurface(x(bds,:,:),y(bds,:,:),z(bds,:,:),...
                          D(bds,:,:,in),newisovalue(in)),'FaceColor',...
                          map{in}(1,:),'EdgeColor','none','FaceAlpha',...
                          opacity(1,in));
                    patch(isocaps(x(bds,:,:),y(bds,:,:),z(bds,:,:),...
                          D(bds,:,:,in),newisovalue(in)),'FaceColor',...
                          'interp','EdgeColor','none','FaceAlpha',...
                          opacity(2,in));
                elseif normalVec == 1
                    patch(isosurface(x(:,bds,:),y(:,bds,:),z(:,bds,:),...
                          D(:,bds,:,in),newisovalue(in)),'FaceColor',...
                          map{in}(1,:),'EdgeColor','none','FaceAlpha',...
                          opacity(1,in));
                    patch(isocaps(x(:,bds,:),y(:,bds,:),z(:,bds,:),...
                          D(:,bds,:,in),newisovalue(in)),'FaceColor',...
                          'interp','EdgeColor','none','FaceAlpha',...
                          opacity(2,in));
                elseif normalVec == 2
                    patch(isosurface(x(:,:,bds),y(:,:,bds),z(:,:,bds),...
                          D(:,:,bds,in),newisovalue(in)),'FaceColor',...
                          map{in}(1,:),'EdgeColor','none','FaceAlpha',...
                          opacity(1,in));
                    patch(isocaps(x(:,:,bds),y(:,:,bds),z(:,:,bds),...
                          D(:,:,bds,in),newisovalue(in)),'FaceColor',...
                          'interp','EdgeColor','none','FaceAlpha',...
                          opacity(2,in));
                else
                    error("normalVec should be 0, 1, or 2");
                end

            end

        end
        
        view(view_angle); % Set view angle
        
        % If hex3 == true, we plot two more unit cells rotated by 120° and
        % 240° around the z-axis, which is a common way to visualize
        % hexagonal unit cells. 
        if hex3
            
            for rotation = [120,240] % Angle of rotation, in degrees
                
                % Create rotation matrix to apply to our data coordinates
                rot_matrix = [ cosd(rotation), sind(rotation), 0;
                              -sind(rotation), cosd(rotation), 0;
                                            0,              0, 1];

                % Put x, y, and z data into a 2D array coord_set, where
                % each row represents the coordinates of one data point.
                % This allows us to apply the rotation matrix to our data
                size_grid = (grid(1)+1)*(grid(2)+1)*(grid(3)+1);
                coord_set = zeros(size_grid,3);
                counter = 0;
                for iz = 1:grid(3)+1
                    for iy = 1:grid(2)+1
                        for ix = 1:grid(1)+1
                            counter = counter +1;
                            coord_set(counter,1) = x(ix,iy,iz);
                            coord_set(counter,2) = y(ix,iy,iz);
                            coord_set(counter,3) = z(ix,iy,iz);
                        end
                    end
                end

                % Apply rotation matrix to data
                coord_set = coord_set*rot_matrix;
                
                % Put data back into 3D arrays x2, y2, and z2 for plotting
                counter = 0;
                x2 = zeros(size(x));
                y2 = zeros(size(y));
                z2 = zeros(size(z));
                for iz = 1:grid(3)+1
                    for iy = 1:grid(2)+1
                        for ix = 1:grid(1)+1
                            counter = counter +1;
                            x2(ix,iy,iz) = coord_set(counter,1) ;
                            y2(ix,iy,iz) = coord_set(counter,2) ;
                            z2(ix,iy,iz) = coord_set(counter,3) ;
                        end
                    end
                end
                clear coord_set

                % Plot the isosurface, isocaps, and unit cell outline for 
                % the rotated unit cell
                patch(isosurface(x2,y2,z2,D(:,:,:,in),newisovalue(in)), ...
                      'FaceColor',map{in}(1,:),'EdgeColor','none', ...
                      'FaceAlpha',opacity(1,in));
                patch(isocaps(x2,y2,z2,D(:,:,:,in),newisovalue(in)), ...
                      'FaceColor','interp','EdgeColor','none', ...
                      'FaceAlpha',opacity(2,in));
                
                if in == 1
                    basis_2 = basis * rot_matrix; % rotated basis vecs
                    draw_box(basis_2,'LineWidth',line_width,...
                             'EdgeColor',line_color);
                end
                
            end
        end
    end
    
    % Set colormap
    colormap(newmap);
    caxis([0,size(newmap,1)-1]);
    
    % Draw box around outside of unit cell
    draw_box(basis,'LineWidth',line_width,'EdgeColor',line_color);

    % Fix data aspect ratio and set axis limits to "tight" setting
    daspect([1 1 1]);  % Equates the data aspect ratio for each axis
    axis tight;        % Snaps the axis to the data set

    % If thin film, extend axis limits to unit cell boundary
    % (unless there is a substrate)
    if ~substrate
        if normalVec == 0
            xlim(ax_main,alims*sum(basis(:,1)));
        elseif normalVec == 1
            ylim(ax_main,blims*sum(basis(:,2)));
        elseif normalVec == 2
            zlim(ax_main,clims*sum(basis(:,3)));
        end
    end
    
    % ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    %% Create colorbars and make them look good

    tmp = colorbar; % Create temporary colorbar in the default position
    set(ax_main,"Units","Points") % Absolute units rather than reduced
    set(tmp,"Units","Points")         % Absolute units rather than reduced
    
    % Below, we find the aspect ratio of the 2D projection of our 3D plot,
    % which depends on the viewing angle. We will then set the width/height
    % of our axes object to match this aspect ratio, which allows the plot
    % to have the same height and left-edge position regardless of unit
    % cell parameters. 
    
    pb = pbaspect; % Plot box aspect ratio
    [az,el] = view(); % viewing angle
    aspect_ratio = get_aspect_ratio(az,el,pb); % aspect ratio of plot
    
    % Fix the axes to reflect the correct aspect ratio
    ax_pos = get(ax_main,"Position"); % Get current axes position
    ax_pos(3) = ax_pos(4) * aspect_ratio; % Fix aspect ratio
    if ax_pos(3) < t_size(3)
        ax_pos(3) = t_size(3);
    end
    
    set(ax_main,"Position",ax_pos);   % Apply adjusted axes position
    delete(tmp) % Delete the temporary colorbar that we used to move the 
                % axes leftward
    
    % Set up for the case of multiple rows of colorbars
    n_cbars = n_species;
    ncol = ceil(n_cbars/cb_rows);
    if cb_rows > 1 % If we need to calculate positions of multiple cb rows
        
        % See how tall the colorbar title is
        title1 = strcat('\phi','_',mono_label(1));
        tmp = text(0,0,0,title1,'fontsize',fontsize*1.1); % Plot the text
        set(tmp,"Units","Points");
        txt_height = get(tmp,"Extent"); % Find height of the text box
        txt_height = txt_height(4);
        delete(tmp) % Delete the temporary text we plotted
        
        % Get variables needed to determine colorbar positions
        title_h = txt_height * 1.3 + 10; % Space allocated for cb titles
        total_h = ax_pos(4); % Total height of each column
        top_pos = ax_pos(4)+ax_pos(2); % coordinate of top edge of column
        cb_space = total_h - (title_h * (cb_rows-1)); 
        rows = 1:cb_rows;
        
        % construct cb_y, a list of the y-coordinates of the colorbars in
        % each row. cb_y(r) is the y-coord of the colorbar in row r.
        cb_h = cb_space / cb_rows; % height of all colorbars
        cb_y = top_pos - (rows*cb_h) - ((rows-1)*title_h); 
        
    else % Only 1 colorbar row, use default height
        
        cb_y = ones(n_cbars,1) * ax_pos(2); % y coord of each colorbar
        cb_h = ax_pos(4); % height of each colorbar
        
    end
    
    % set x-coord of first colorbar column, 40pts right of the axes object
    cb_x = ax_pos(1)+ax_pos(3)+40; 
    
    % Loop over columns/rows of colorbars and create colorbars
    for col = 1:ncol
        txt_width = 0; % variable to help us set colorbar locations
        for row = 1:cb_rows
            
            % Colorbar position number (left to right, top to bottom)
            pos = (row-1)*ncol + col; 
            
            % If this column/row should contain a colorbar:
            if pos <= n_cbars
                
                % Monomer index for this row/column
                in = species(pos);

                % Colorbar data limits
                cb_start = isovalue(in);
                cb_end = max_comps(in);

                % Create cb ticklabels according to specs provided by user
                cblabel = linspace(cb_start,cb_end,cb_ticks);
                tick_format = strcat('%.',string(n_digits(in)),'f');
                cblabel = compose(tick_format,cblabel');
                l_lngth = linspace(0,1,cb_ticks);

                % Create a new invisible axes object for this colorbar
                ax(in) = axes("Units","Points"); %#ok<AGROW> 
                set(ax(in),"Visible","off","XTick",[],"YTick",[],...
                    "ZTick",[],"InnerPosition",ax_pos);

                % Assign the appropriate colormap to this axes object
                colormap(ax(in),map{in});

                % Create the colorbar
                cb(in) = colorbar(ax(in)); %#ok<AGROW> 
                cb_pos = [cb_x,cb_y(row),22,cb_h];
                set(cb(in),"axislocation","out","Units","Points",...
                    "ytick",l_lngth,"ticklabels",cblabel,...
                    "fontsize",fontsize,"Position",cb_pos,"color","k");
                title1 = strcat('\phi','_',mono_label(in));
                title(cb(in),title1,'fontsize',fontsize*1.1);
                
                % Estimate the width of our ticklabels, and if it is larger
                % than txt_width then update txt_width
                [~,ind] = max(strlength(cblabel)); %Find longest ticklabel
                tmp = text(0,0,0,cblabel(ind),'fontsize',fontsize); 
                set(tmp,"Units","Points");
                txt_extent = get(tmp,"Extent"); % Find width of the text
                if txt_extent(3) > txt_width % Update txt_width if needed
                    txt_width = txt_extent(3);
                end
                delete(tmp) % Delete the temporary text we plotted
                
            end
        end
        
        % Update colorbar x-position for the next row
        cb_x = cb_x + 22 + txt_width + 20; 
        
    end
    
    %% Finish

    % Update figure size to show everything we want to show
    set(fig,'Units','Points');
    fig_pos = get(fig,'position');
    fig_pos(3) = cb_x * 1.05; % Make figure wide enough to see all cbs
    % Make figure taller to fit cb titles
    fig_pos(4) = fig_pos(4) + (fontsize*1.1); 
    set(fig,'position',fig_pos);

    drawnow % this refreshes all graphics objects (processes callbacks).
            % The colorbars end up too big if we don't call this here

    % Add light if desired
    if light_on
        light(ax_main,'position',[-1 -1 1]);
        light(ax_main,'position',[-1 -1 0]);
        lighting(ax_main,"gouraud");
    end

    % Hide axes if desired
    if hide_axes
        set(ax_main,'visible','off')
    end
    
    % Save figure if a filename is provided
    if savefile ~= ""
        [~,~,ext] = fileparts(savefile);
        if (ext == ".fig") || (ext == ".m")
            saveas(fig,savefile);
        else
            if ext == ".jpg"
                format = "-djpeg";
            elseif ext == ".tif"
                format = "-dtiff";
            else
                format = strcat("-d", extractAfter(ext,1));
            end
            res = strcat("-r",num2str(resolution));
            print(fig,savefile,format,res);
        end
    end
    
    % Prep figure for interactive use
    set(ax_main,'Units','Normalized')
    set(fig,'Units','Normalized')
    for is = 1:n_species
        in = species(is);
        % Set units back to normalized so that the axes and 
        % colorbars will change size correctly when the size of
        % the figure is modified
        set(ax(in),"Units","Normalized");
        set(cb(in),"Units","Normalized");
    end
    rotate3d on;
    uistack(ax_main,'top') % Allows rotate3d to rotate the main axis
    
    drawnow
    hold off

end
