% Drawing individual composition profiles for each species in a converged
% SCFT solution.

function individual_profiles(R,x,y,z,options)
    %% Define all input variables and name/value pair options:
    arguments
        
        % The first parameter of this function, R, is "overloaded". This
        % means that the function accepts either a string or a data array 
        % for the first parameter, and it will work correctly either way. 
        
        % If the first parameter is a string, we assume it is a filename
        % that contains the data we wish to plot. Thus, we will use
        % read_rgrid.m to collect the data that will be plotted.
        
        % If the first parameter is instead a data array, it must contain
        % all of the composition data stored in the rgrid file. For an
        % N-dimensional system, R must be an (N+1)-dimensional array. In
        % 3D, R(i,j,k,l) gives the composition of species l at gridpoint
        % (i,j,k). 
        R
        
        % If R is a data array, then the real-space coordinates
        % corresponding to those data must be provided as well. For a 2D
        % system, x and y are needed, while z is also needed in 3D. For a
        % system discretized into an i x j x k grid, these arrays must
        % have size (i,j,k), where x(i,j,k) corresponds to the x-coordinate
        % of the data points in R(i,j,k,:), and so on for y and z.
        
        % x and y are only made optional to allow for the user to run
        % individual_profiles(filename) without causing an error.
        % If the first input parameter is a filename (a string), x, y, and 
        % z are deleted and regenerated by the function read_rgrid.
        % However, if R is a data array and x and y are not provided, an
        % error will occur.
        x = []
        y = []
        z = []
        
        % ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        % The rest of the inputs are optional name-value pair inputs:

        % savefile is a filename to which the figures will be saved.
        % The file extension provided (e.g. ".fig" or ".png") will be used
        % to determine the type of file to save. Since this function
        % typically generates more than 1 figure, we append mono_label(i)
        % to the end of the filename when saving the composition profile
        % for species i. If left empty (which is the default behavior), the
        % figures are not saved.
        options.savefile = "";

        % fontsize specifies the FontSize parameter for the axis on which
        % data are plotted. Default value is 10.
        options.fontsize = 14;
        
        % hex3 is a boolean indicating whether to plot 3 unit cells for a
        % hexagonal system rather than 1. 
        options.hex3 = false
        
        % isovalue is an array of isovalues representing the minimum volume
        % fraction to show on plot. One for each species. If not specified,
        % we call get_isovalues.m to calculate them automatically.
        options.isovalue
        
        % mono_label contains labels for each monomer species. If not
        % specified, we use ["A","B","C",...] as the default behavior.
        options.mono_label
         
        % opacity contains values of opacity to plot for each species. 2
        % opacities are specified for each species i: opacity(1,i) is the
        % opacity of the interior of the domains, while opacity(2,i) is the
        % opacity of the exterior (caps) of the domains. If unspecified,
        % all values default to 1 (completely opaque).
        options.opacity
        
        % map is a cell array containing a colormap for each species.
        % map{i} is the colormap for species i. If unspecified, we use the
        % default colormaps generated by get_colormaps.m.
        options.map
        
        % thick is the value for "linethickness" used to draw the outer box
        % of the unit cell. Default is 1
        options.thick = 1
        
        % box_color is the value for "color" used to draw the outer box of
        % the unit cell. Default is gray.
        options.box_color = [0.5,0.5,0.5]
        
        % make_3d is a boolean. If true, it will plot a 2D dataset in 3D.
        options.make_3d = false;

        % cb_ticks is the number of ticks on the colorbar, default is 10.
        options.cb_ticks = 10;
        
        % n_digits is the number of digits past the decimal point to use
        % for the colorbar tick labels. Can be specified as a scalar, or as
        % an array of length n_mnr (one value per monomer species plotted)
        % if you want a different # of digits for each colorbar. Default is
        % 3.
        options.n_digits = 3;
        
    end
    
    % if a filename is passed to the function, read data from that file
    if ischar(R) || isstring(R) 
        
        clear x y z; % We will determine x, y, and z from the rgrid file
        close all; % close other figures
                
        % Read data from file
        [R,x,y,z,dim,lattype,cell_d,angle,n_mnr,grid] = read_rgrid(R);
        
        % If hex3 is true, make sure system is actually hexagonal
        if options.hex3 && strcmp(lattype,'hexagonal') == 0
            error("hex3 is true but crystal system is not hexagonal")
        end
        
        % Get lattice basis vectors
        basis = get_basis(cell_d,angle);
    
    % If R is not a string defining a filename, we assume it is a data
    % array containing species compositions. So, below we make sure we have
    % all of the other data we need to proceed, and define some useful
    % variables.
    else
        
        % Make sure that we have x and y (and z if data are 3D):
        if isempty(x) || isempty(y) % if x or y are not provided
            error("Necessary coordinates of data were not provided")
        elseif ndims(x) == 3 && isempty(z) % R is 3D and z is not provided
            error("z coordinates were not provided for 3D data")
        end
        
        dim = ndims(x);
        % Define grid, basis, and n_mnr (defined differently in 2D vs 3D)
        if dim == 3
            grid = [size(R,1)-1,size(R,2)-1,size(R,3)-1];
            n_mnr = size(R,4);
            basis = [x(end,1,1),y(end,1,1),z(end,1,1);
                     x(1,end,1),y(1,end,1),z(1,end,1);
                     x(1,1,end),y(1,1,end),z(1,1,end);];
        elseif dim == 2
            n_mnr = size(R,3);
            basis = [x(end,1), y(end,1); x(1,end), y(1,end)];
            if options.make_3d
                grid = [size(R,1)-1,size(R,2)-1,10];
                
                % use the make_3d function to expand the 2D data into a
                % third dimension with z-height equal to the average length
                % of the two lattice basis vectors
                height = (norm(basis(1,:)) + norm(basis(2,:))) / 2;
                [R,x,y,z] = make_3d(R,x,y,height);
                basis = [basis(1,1), basis(1,2), 0;
                         basis(2,1), basis(2,2), 0;
                         0,          0,          height];
            else
                grid = [size(R,1)-1,size(R,2)-1];
            end
        else
            error("x array should be either 2 or 3 dimensions")
        end
        
    end
    
    % Get other parameters needed for composition profiles, using
    % default values if they are not provided as name-value inputs:
    if isfield(options,'mono_label')
        mono_label = options.mono_label;
    else
        mono_label = char(1,3);
        for in = 1:n_mnr
            mono_label(in) = char('A'+in-1);
        end
    end
    
    if isfield(options,'opacity')
        opacity = options.opacity;
    else
        opacity = ones(2,n_mnr);
    end
    
    if isfield(options,'map')
        map = options.map;
    else
        map = get_colormaps();
    end
    
    if isfield(options,'isovalue')
        isovalue = options.isovalue;
    else
        isovalue = get_isovalues(R,dim,n_mnr,grid,false,map);
    end
    
    if isscalar(options.n_digits)
        n_digits = ones(1,n_mnr) * options.n_digits;
    else
        if length(options.n_digits) ~= n_mnr
            error('n_digits must be a scalar or an array of length n_mnr')
        end
        n_digits = options.n_digits;
    end
    
    hex3 = options.hex3; 
    thick = options.thick; 
    box_clr = options.box_color;
    cb_ticks = options.cb_ticks;
    savefile = options.savefile;
    fontsize = options.fontsize;
    clear options
    
    %% Create the composition profile for each species
    for in = 1:n_mnr
        
        figure(); hold on; set(gca,'fontsize',fontsize)
        title(strcat(mono_label(in),' Block Density Profile'))

        % Plot isosurfaces, isocaps, and unit cell outlines
        patch(isosurface(x,y,z,R(:,:,:,in),isovalue(in)), ...
              'FaceColor',map{in}(1,:),'EdgeColor','none',...
              'FaceAlpha',opacity(1,in));
        fvc = isocaps(x,y,z,R(:,:,:,in),isovalue(in));
        patch(fvc,'FaceColor','interp','EdgeColor','none',...
              'FaceAlpha',opacity(2,in));
        draw_lattice(basis,thick,box_clr);
        
        % Set colormap
        colormap(map{in})
        
        % We only need to show the colorbar if the isosurface intersects
        % with the faces of the unit cell. Thus, we use the data from the
        % isocaps to determine if we need to plot the colorbars.
        max_color = max(fvc.facevertexcdata);
        if isovalue(in) < max_color 
            
            % Create colorbar:
            cb_start = isovalue(in);
            cb_end = max_color;

            cblabel = round(linspace(cb_start,cb_end,cb_ticks),...
                            n_digits(in));
            tick_format = strcat('%.',string(n_digits(in)),'f');
            cblabel = compose(tick_format,cblabel');
            
            l_lngth = linspace(cb_start,cb_end,cb_ticks);
            cbh = colorbar;
            set(cbh,'ylim',[cb_start cb_end],'ytick',...
                l_lngth,'Yticklabel',cblabel,'fontsize',fontsize)

            title1 = strcat('\phi','_',mono_label(in));
            title(cbh,title1,'fontsize',fontsize*1.1)
        
        % If colorbar is not needed, we opt instead to add a text box
        % indicating the value of the isovalue we are showing.
        else

            % Creating the label for the isovalue(in)
            text_disp = strcat('\phi','_',mono_label(in),'=',...
                               num2str(round(isovalue(in),n_digits(in)))); 

            % Setting the location for the label
            text(x(grid(1)+1,1,round(grid(3)/2)), ...
                 y(grid(1)+1,1,round(grid(3)/2)), ...
                 z(grid(1)+1,1,round(grid(3)/2)),...
                 text_disp,'color',map{in}(end,:),'fontsize',fontsize+4)
             
        end
        
        % If hex3 == true, we plot two more unit cells rotated by 120° and
        % 240° around the z-axis, which is a common way to visualize
        % hexagonal unit cells. 
        if hex3
            
            for rotation = [120,240] % Angle of rotation, in degrees
                
                % Create rotation matrix to apply to our data coordinates
                rot_matrix = [ cosd(rotation), sind(rotation), 0;
                              -sind(rotation), cosd(rotation), 0;
                                            0,              0, 1];

                % Put x, y, and z data into a 2D array coord_set, where
                % each row represents the coordinates of one data point.
                % This allows us to apply the rotation matrix to our data
                size_grid = (grid(1)+1)*(grid(2)+1)*(grid(3)+1);
                coord_set = zeros(size_grid,3);
                counter = 0;
                for iz = 1:grid(3)+1
                    for iy = 1:grid(2)+1
                        for ix = 1:grid(1)+1
                            counter = counter +1;
                            coord_set(counter,1) = x(ix,iy,iz);
                            coord_set(counter,2) = y(ix,iy,iz);
                            coord_set(counter,3) = z(ix,iy,iz);
                        end
                    end
                end

                % Apply rotation matrix to data
                coord_set = coord_set*rot_matrix;
                
                % Put data back into 3D arrays x2, y2, and z2 for plotting
                counter = 0;
                x2 = zeros(size(x));
                y2 = zeros(size(y));
                z2 = zeros(size(z));
                for iz = 1:grid(3)+1
                    for iy = 1:grid(2)+1
                        for ix = 1:grid(1)+1
                            counter = counter +1;
                            x2(ix,iy,iz) = coord_set(counter,1) ;
                            y2(ix,iy,iz) = coord_set(counter,2) ;
                            z2(ix,iy,iz) = coord_set(counter,3) ;
                        end
                    end
                end
                clear coord_set

                % Plot the isosurface, isocaps, and unit cell outline for 
                % the rotated unit cell
                patch(isosurface(x2,y2,z2,R(:,:,:,in),isovalue(in)), ...
                      'FaceColor',map{in}(1,:),'EdgeColor','none', ...
                      'FaceAlpha',opacity(1,in));
                patch(isocaps(x2,y2,z2,R(:,:,:,in),isovalue(in)), ...
                      'FaceColor','interp','EdgeColor','none', ...
                      'FaceAlpha',opacity(2,in));
                basis_2 = basis * rot_matrix; % rotated basis vecs
                draw_lattice(basis_2,thick,box_clr);

            end
        end

        % Set view
        if size(basis,1) == 3
            view(3); % Sets 3-D view
        elseif size(basis,1) == 2
            view(2); % Sets 2-D view
        end

        % Fix data aspect ratio and set axis limits to "tight" setting
        daspect([1 1 1]);  % Equates the data aspect ratio for each axis
        axis tight;        % Snaps the axis to the data set

        % Lighting options
        %   set(p2,'AmbientStrength',.6);
        %   set(p1,'AmbientStrength',.5);

        %   isonormals(data,p1);
        %   lightangle(45,30);
        %   lighting phong
        
        % Set aspect ratio of the axes to be equal to that of the plot
        pb = pbaspect; % Plot box aspect ratio
        [az,el] = view(); % viewing angle
        aspect_ratio = get_aspect_ratio(az,el,pb); % aspect ratio of plot
        set(gca,'Units','Points'); % Fixed units rather than reduced units
        ax_pos = get(gca,'Position');
        ax_pos(3) = ax_pos(4) * aspect_ratio;
        set(gca,'Position',ax_pos);
        
        if isovalue(in) < max_color % If we have a colorbar
            
            % Estimate the width of our ticklabels
            [~,ind] = max(strlength(cblabel)); %Find longest ticklabel
            tmp = text(0,0,0,cblabel(ind),'fontsize',fontsize); 
            set(tmp,"Units","Points");
            txt_extent = get(tmp,"Extent"); % Find width of the text
            txt_width = txt_extent(3);
            delete(tmp) % Delete the temporary text we plotted

            % Update figure size to fit everything on the figure
            set(cbh,'Units','Points'); % Fixed units rather than reduced
            set(gcf,'Units','Points');
            cb_pos = get(cbh,'Position');
            fig_pos = get(gcf,'position');
            % Make figure wide enough to see colorbar
            fig_pos(3) = (cb_pos(1) + cb_pos(3)) + txt_width + 40;
            % Make figure taller to fit cb titles
            fig_pos(4) = fig_pos(4) + (fontsize*1.1); 
            set(gcf,'position',fig_pos);
            
        else
            
            % Make figure a little taller, just for aesthetics
            set(gcf,'Units','Points');
            fig_pos = get(gcf,'position');
            fig_pos(4) = fig_pos(4) + (fontsize*1.1);
            set(gcf,'position',fig_pos);
            
        end
        
        % Save figure if a filename is provided
        if savefile ~= ""
            [f_path,f_name,f_ext] = fileparts(savefile);
            save_filename = fullfile(f_path, ...
                                strcat(f_name,mono_label(in),f_ext));
            saveas(gcf,save_filename);
        end
        
        rotate3d on
        hold off

    end
end
