% Drawing individual composition profiles for each species in a converged
% SCFT solution.

function individual_profiles(R,x,y,z,options)
    
    arguments
        
        % The first parameter of this function, R, is "overloaded". This
        % means that the function accepts either a string or a data array 
        % for the first parameter, and it will work correctly either way. 
        
        % If the first parameter is a string, we assume it is a filename
        % that contains the data we wish to plot. Thus, we will use
        % read_rgrid.m to collect the data that will be plotted.
        
        % If the first parameter is instead a data array, it must contain
        % all of the composition data stored in the rgrid file. For an
        % N-dimensional system, R must be an (N+1)-dimensional array. In
        % 3D, R(i,j,k,l) gives the composition of species l at gridpoint
        % (i,j,k). 
        R
        
        % If R is a data array, then the real-space coordinates
        % corresponding to those data must be provided as well. For a 2D
        % system, x and y are needed, while z is also needed in 3D. For a
        % system discretized into an i x j x k grid, these arrays must
        % have size (i,j,k), where x(i,j,k) corresponds to the x-coordinate
        % of the data points in R(i,j,k,:), and so on for y and z.
        
        % x and y are only made optional to allow for the user to run
        % individual_profiles(filename) without causing an error.
        % If the first input parameter is a filename (a string), x, y, and 
        % z are deleted and regenerated by the function read_rgrid.
        % However, if R is a data array and x and y are not provided, an
        % error will occur.
        x = []
        y = []
        z = []
        
        % ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        % The rest of the inputs are optional name-value pair inputs:
        
        % hex3 is a boolean indicating whether to plot 3 unit cells for a
        % hexagonal system rather than 1. 
        options.hex3 = false
        
        % isovalue is an array of isovalues representing the minimum volume
        % fraction to show on plot. One for each species. If not specified,
        % we call get_isovalues.m to calculate them automatically.
        options.isovalue
        
        % mono_label contains labels for each monomer species. If not
        % specified, we use ["A","B","C",...] as the default behavior.
        options.mono_label
         
        % opacity contains values of opacity to plot for each species. 2
        % opacities are specified for each species i: opacity(i,1) is the
        % opacity of the interior of the domains, while opacity(i,2) is the
        % opacity of the exterior (caps) of the domains. If unspecified,
        % all values default to 1 (completely opaque).
        options.opacity
        
        % map is a cell array containing a colormap for each species.
        % map{i} is the colormap for species i. If unspecified, we use the
        % default colormaps generated by get_colormaps.m.
        options.map
        
        % thick is the value for "linethickness" used to draw the outer box
        % of the unit cell. Default is 1
        options.thick = 1
        
        % box_color is the value for "color" used to draw the outer box of
        % the unit cell. Default is gray.
        options.box_color = [0.5,0.5,0.5]
        
        % make_3d is a boolean. If true, it will plot a 2D dataset in 3D.
        options.make_3d = false;
        
    end

    if ischar(R) || isstring(R) % if a filename is passed to the function
        
        clear x y z;
                
        % Read data from file
        [R,x,y,z,dim,lattype,cell_d,angle,n_mnr,grid] = read_rgrid(R);
        
        % If hex3 is true, make sure system is actually hexagonal
        if options.hex3 && strcmp(lattype,'hexagonal') == 0
            error("hex3 is true but crystal system is not hexagonal")
        end
        
        % Get lattice basis vectors
        basis = get_basis(cell_d,angle);
        
    elseif ismatrix(R) % R is a data array containing species compositions
        
        % Make sure that we have x and y (and z if data are 3D):
        if isempty(x) || isempty(y) % if x or y are not provided
            error("Necessary coordinates of data were not provided")
        elseif ndims(x) == 3 && isempty(z) % R is 3D and z is not provided
            error("z coordinates were not provided for 3D data")
        end
        
        % Define grid, basis, and n_mnr (defined differently in 2D vs 3D)
        if ndims(x) == 3
            grid = [size(R,1)-1,size(R,2)-1,size(R,3)-1];
            n_mnr = size(R,4);
            basis = [x(end,1,1),y(end,1,1),z(end,1,1);
                     x(1,end,1),y(1,end,1),z(1,end,1);
                     x(1,1,end),y(1,1,end),z(1,1,end);];
        elseif ndims(x) == 2 %#ok<ISMAT>
            n_mnr = size(R,3);
            basis = [x(end,1), y(end,1); x(1,end), y(1,end)];
            if options.make_3d
                grid = [size(R,1)-1,size(R,2)-1,10];
                
                % use the make_3d function to expand the 2D data into a
                % third dimension with z-height equal to the average length
                % of the two lattice basis vectors
                height = (norm(basis(1,:)) + norm(basis(2,:))) / 2;
                [R,x,y,z] = make_3d(R,x,y,height);
                basis = [basis(1,1), basis(1,2), 0;
                         basis(2,1), basis(2,2), 0;
                         0,          0,          height];
            else
                grid = [size(R,1)-1,size(R,2)-1];
            end
        else
            error("x should have either 2 or 3 dimensions")
        end
        
    else
        
        error("First variable must either be data matrix or filename")
    
    end
    
    
    % Get other parameters needed for composition profiles, using
    % default values if they are not provided as name-value inputs

    if isfield(options,'mono_label')
        mono_label = options.monolabel;
    else
        mono_label = char(1,3);
        for in = 1:n_mnr
            mono_label(in) = char('A'+in-1);
        end
    end
    
    if isfield(options,'opacity')
        opacity = options.opacity;
    else
        opacity = ones(n_mnr,2);
    end
    
    if isfield(options,'map')
        map = options.map;
    else
        map = get_colormaps(3);
    end
    
    if isfield(options,'isovalue')
        isovalue = options.isovalue;
    else
        isovalue = get_isovalues(R,dim,n_mnr,grid,false,map);
    end
    
    hex3 = options.hex3; 
    thick = options.thick; 
    box_clr = options.box_color;
    clear options
    
    
    % Create the composition profile for each species
    for in = 1:n_mnr
        
        figure(); hold on
        
        title(strcat(mono_label(in),' Block Density Profile'))
        patch(isosurface(x,y,z,R(:,:,:,in),isovalue(in)), ...
              'FaceColor',map{in}(1,:),'EdgeColor','none',...
              'FaceAlpha',opacity(in,1));
        fvc = isocaps(x,y,z,R(:,:,:,in),isovalue(in));
        patch(fvc,'FaceColor','interp','EdgeColor','none',...
              'FaceAlpha',opacity(in,2));
          
        colormap(map{in})

        if isovalue(in) < max(R(:,:,:,in)) % If we need a colorbar on the plot

            cblabelstart = isovalue(in);
            cblabelend = max(data);

            n_labels = 10;

            if cblabelend - cblabelstart > 0.1
                cblabel = round(linspace(cblabelstart,cblabelend,n_labels),2);
            else
                cblabel = round(linspace(cblabelstart,cblabelend,n_labels),3);
            end
            l_lngth = linspace(cblabelstart,cblabelend,10);
            cbh = colorbar;
            set(cbh,'ylim',[cblabelstart cblabelend],'ytick',...
                l_lngth,'Yticklabel',cblabel)

            title1 = strcat('\phi','_',mono_label(in));
            title(cbh,title1)

        else
            % Creating the label for the isovalue(in)
            text_disp = strcat('\fontsize{14}\phi','_',mono_label(in),'=',...
                               num2str(round(isovalue(in),2))); 

            % Setting the location for the label
            text(x(grid(1)+1,1,round(grid(3)/2)), ...
                 y(grid(1)+1,1,round(grid(3)/2)), ...
                 z(grid(1)+1,1,round(grid(3)/2)),...
                 text_disp,'color',map{in}(1,:))
        end

        if hex3

            % Draw unit cell outlines for the second and third unit cells:
            rot_matrix = rotz(120); % Rotation of 120Â° around z axis
            basis_2 = (rot_matrix * (basis'))';
            basis_3 = (rot_matrix * (basis'))';
            draw_lattice(basis_2,thick,box_clr) % Draw second unit cell
            draw_lattice(basis_3,thick,box_clr) % Draw second unit cell

            for rotation = 1:2
                size_grid = (grid(1)+1)*(grid(2)+1)*(grid(3)+1);
                coord_set = zeros(size_grid,3);
                counter = 0;

                for iz = 1:grid(3)+1
                    for iy = 1:grid(2)+1
                        for ix = 1:grid(1)+1
                            counter = counter +1;
                            coord_set(counter,1) = x(ix,iy,iz) ;
                            coord_set(counter,2) = y(ix,iy,iz) ;
                            coord_set(counter,3) = z(ix,iy,iz) ;
                        end
                    end
                end

                coord_set = coord_set*rot_matrix;

                counter = 0;
                x2 = zeros(size(x));
                y2 = zeros(size(y));
                z2 = zeros(size(z));
                for iz = 1:grid(3)+1
                    for iy = 1:grid(2)+1
                        for ix = 1:grid(1)+1
                            counter = counter +1;
                            x2(ix,iy,iz) = coord_set(counter,1) ;
                            y2(ix,iy,iz) = coord_set(counter,2) ;
                            z2(ix,iy,iz) = coord_set(counter,3) ;
                        end
                    end
                end

                patch(isosurface(x2,y2,z2,R(:,:,:,in),isovalue(in)), ...
                      'FaceColor',map{in}(1,:),'EdgeColor','none', ...
                      'FaceAlpha',opacity(in,1));
                patch(isocaps(x2,y2,z2,R(:,:,:,in),isovalue(in)), ...
                      'FaceColor','interp','EdgeColor','none', ...
                      'FaceAlpha',opacity(in,2));

            end
        end

        if dim == 3
            view(3);                        %Sets 3-D view
        elseif dim == 2
            view(2);                        %Sets 2-D view
        elseif dim == 1
            view(2);                        %Sets 2-D view
        end

        axis equal;               %Equates the aspect ratio for each axis
        axis vis3d;               %Freezes aspect ratio (allowing rotation)
        %axis tight;              %Snaps the axis to the data set

        draw_lattice(basis,thick,box_clr)

        set(gcf,'Renderer','zbuffer');

        rotate3d

        hold off

        % Lighting options
        %   set(p2,'AmbientStrength',.6);
        %   set(p1,'AmbientStrength',.5);

        %   isonormals(data,p1);
        %   lightangle(45,30);
        %   lighting phong
    end
end
