% Drawing individual composition profiles for each species in a converged
% SCFT solution.

function individual_profiles(R,x,y,z,dim,options)
    %% Define all input variables and name/value pair options:
    arguments
        
        % The first parameter of this function, R, is "overloaded". This
        % means that the function accepts either a string or a data array 
        % for the first parameter, and it will work correctly either way. 
        
        % If the first parameter is a string, we assume it is a filename
        % that contains the data we wish to plot. Thus, we will use
        % read_rgrid.m to collect the data that will be plotted.
        
        % If the first parameter is instead a data array, it must contain
        % all of the composition data stored in the rgrid file. For an
        % N-dimensional system, R must be an (N+1)-dimensional array. In
        % 3D, R(i,j,k,l) gives the composition of species l at gridpoint
        % (i,j,k). 
        R
        
        % If R is a data array, then the real-space coordinates
        % corresponding to those data must be provided as well. For a 2D
        % system, x and y are needed, while z is also needed in 3D. For a
        % system discretized into an i x j x k grid, these arrays must
        % have size (i,j,k), where x(i,j,k) corresponds to the x-coordinate
        % of the data points in R(i,j,k,:), and so on for y and z.
        
        % x and y are only made optional to allow for the user to run
        % individual_profiles(filename) without causing an error.
        % If the first input parameter is a filename (a string), x, y, and 
        % z are deleted and regenerated by the function read_rgrid.
        % However, if R is a data array and x and y are not provided, an
        % error will occur.
        x = []
        y = []
        z = []
        dim = 0
        
        % ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        % The rest of the inputs are optional name-value pair inputs:

        % savefile is a filename to which the figures will be saved.
        % The file extension provided (e.g. ".fig" or ".png") will be used
        % to determine the type of file to save. Since this function
        % typically generates more than 1 figure, we append mono_label(i)
        % to the end of the filename when saving the composition profile
        % for species i. If left empty (which is the default behavior), the
        % figures are not saved.
        options.savefile = "";

        % resolution is a number that specifies the resolution of the
        % figure that is saved (if options.savefile is specified), in dots
        % per inch (dpi). Default value is 300. If set to 0, file is saved
        % at screen resolution.
        options.resolution = 300;

        % fontsize specifies the FontSize parameter for the axis on which
        % data are plotted. Default value is 14.
        options.fontsize = 14;
        
        % hex3 is a boolean indicating whether to plot 3 unit cells for a
        % hexagonal system rather than 1. 
        options.hex3 = false

        % light is a boolean indicating whether to insert a "light" object
        % into the plot (adds shadows that can make 3d structure clearer,
        % but invalidates the accuracy of the colorbar).
        options.light = false;

        % view is a 1, 2, or 3-element vector that specifies the viewing
        % angle of the figure(s). If this is included, we call 
        % view(options.view) to set the viewing angle, so options.view must
        % be something that complies with the view() function. If view = 2
        % or view = 3, the view will be the default 2D or 3D view,
        % respectively. If view is a 2-element vector, the two elements
        % correspond to the azimuth and elevation angles, respectively. If
        % view is a 3-element vector, the values represent a vector that
        % points from the origin to the viewer. 
        options.view;

        % If hide_axes is set to true, the plot will not contain the tick 
        % marks, title, etc. by setting the "visible" property of the axes
        % to "off".
        options.hide_axes = false;
        
        % isovalue is an array of isovalues representing the minimum volume
        % fraction to show on plot. One for each species. If not specified,
        % we call get_isovalues.m to calculate them automatically.
        options.isovalue
        
        % mono_label contains labels for each monomer species. If not
        % specified, we use ["A","B","C",...] as the default behavior.
        options.mono_label
         
        % opacity contains values of opacity to plot for each species. 2
        % opacities are specified for each species i: opacity(1,i) is the
        % opacity of the interior of the domains, while opacity(2,i) is the
        % opacity of the exterior (caps) of the domains. If unspecified,
        % all values default to 1 (completely opaque).
        options.opacity
        
        % map is a cell array containing a colormap for each species.
        % map{i} is the colormap for species i. If unspecified, we use the
        % default colormaps generated by get_colormaps.m.
        options.map
        
        % line_width is the value for "LineWidth" used to draw the outer 
        % box of the unit cell. Default is 1
        options.line_width = 1
        
        % line_color is the value for "EdgeColor" used to draw the outer
        % box of the unit cell. Default is gray. Can be a color string as
        % well, as long as Matlab can interpret it properly as a color,
        % e.g. "y", "yellow", or "#FFFF00" (hexadecimal color code).
        options.line_color = [0.5,0.5,0.5]

        % alim, blim, and clim are 2-element arrays specifying the upper 
        % and lower limits of the region to plot in the 3D composition
        % profiles, in reduced coordinates. Default value is [0,1] for
        % each, which plots a single unit cell. If, say, alim = [0,2], then
        % the profiles will show 2 unit cells along the direction of the 
        % lattice basis vector a.
        options.alim = [0,1];
        options.blim = [0,1];
        options.clim = [0,1];

        % cb_ticks is the number of ticks on the colorbar, default is 10.
        options.cb_ticks = 10;
        
        % n_digits is the number of digits past the decimal point to use
        % for the colorbar tick labels. Can be specified as a scalar, or as
        % an array of length n_mnr (one value per monomer species plotted)
        % if you want a different # of digits for each colorbar. Default is
        % 3.
        options.n_digits = 3;

        % If your SCFT result is a thin film, you should include
        % film_params as an input to apply a thin film correction.
        %
        % film_params is an array with 4 entries. The first 3 entries
        % correspond to the 3 required parameters in pscfpp that are needed
        % to define a Wall object: normalVec, interfaceThickness, and
        % wallThickness. See pscfpp documentation for details about what
        % each of these three parameters means. The fourth entry is a
        % boolean (i.e. 0 for false, 1 for true) that indicates whether or
        % not to rotate the figure to make the z axis orthogonal to the
        % wall. If this film_params input is included, the code will apply
        % a correction to the plot to make the figure look good as a thin
        % film. If it is not included, it is assumed that the data being
        % plotted are not under a thin film constraint.
        options.film_params;

        % substrate is a boolean indicating whether or not to add a box
        % in the composite profile underneath the unit cell that looks 
        % like a substrate on which the polymer rests. The box color, line
        % edge line color, and edge line width can be set by the inputs
        % substrate_color, substrate_line_color, and substrate_line_width, 
        % respectively. 
        %
        % This feature is compatible with all other features, including the
        % thin film correction. The only requirement that we enforce on the
        % other inputs is that clim(1) must be 0. 
        options.substrate = false;
        options.substrate_color = [0.5,0.5,0.5];
        options.substrate_line_color = 'k';
        options.substrate_line_width = 1;
        
        % top_wall is basically identical to substrate, except it places a
        % box on top of the unit cell rather than below it. The appearance
        % of the top_wall can be altered with top_wall_color,
        % top_wall_line_color, and top_wall_line_width. By default, these
        % appearance-related parameters are set to match the corresponding
        % parameters for the substrate.
        options.top_wall = false;
        options.top_wall_color;
        options.top_wall_line_color;
        options.top_wall_line_width;
        
    end
    
    % Ensure that the code below can access our utilities
    [filepath,~,~] = fileparts(mfilename('fullpath'));
    addpath(filepath+"/utilities")    

    % if a filename is passed to the function, read data from that file
    if ischar(R) || isstring(R) 
        
        clear x y z; % We will determine x, y, and z from the rgrid file
        close all; % close other figures
                
        % Read data from file
        [R,x,y,z,dim,lattype] = read_rgrid(R);
        
        % If hex3 is true, make sure system is actually hexagonal
        if options.hex3 && strcmp(lattype,'hexagonal') == 0
            error("hex3 is true but crystal system is not hexagonal")
        end
    
    % If R is not a string defining a filename, we assume it is a data
    % array containing species compositions. So, below we make sure we have
    % all of the other data we need to proceed, and define some useful
    % variables.
    else
        
        % Make sure that we have x, y, z, and dim:
        if isempty(x) || isempty(y) % if x or y are not provided
            error("Necessary coordinates of data were not provided")
        elseif ndims(x) == 3 && isempty(z) % R is 3D and z is not provided
            error("z coordinates were not provided for 3D data")
        elseif dim ~= 1 && dim ~= 2 && dim ~= 3
            error("dim is a required variable & must be either 1, 2, or 3")
        end

    end

    % Get n_mnr, grid, and basis from the R, x, y, and z arrays
    n_mnr = size(R,4);
    grid = size(x) - 1;
    basis = [x(end,1,1),y(end,1,1),z(end,1,1);
             x(1,end,1),y(1,end,1),z(1,end,1);
             x(1,1,end),y(1,1,end),z(1,1,end)];

    % Apply thin film correction if desired
    if isfield(options,'film_params') && ~isempty(options.film_params)
        [R,x,y,z,basis] = thin_film_correction(R,x,y,z,...
                          options.film_params(1),options.film_params(2),...
                          options.film_params(3),options.film_params(4));
        grid = size(R,1:3) - 1; % Update grid
        if options.film_params(4)
            normalVec = 2; % used by change_cell_lims
        else
            normalVec = options.film_params(1); 
        end
    else
        normalVec = -1; % indicates absence of thin film correction
    end
    
    % Get other parameters needed for composition profiles, using
    % default values if they are not provided as name-value inputs:
    if isfield(options,'mono_label')
        mono_label = options.mono_label;
    else
        mono_label = char(1,n_mnr);
        for in = 1:n_mnr
            mono_label(in) = char('A'+in-1);
        end
    end
    
    if isfield(options,'opacity')
        opacity = options.opacity;
    else
        opacity = ones(2,n_mnr);
    end
    
    if isfield(options,'map')
        map = options.map;
    else
        map = get_colormaps();
    end
    
    if isfield(options,'isovalue')
        isovalue = options.isovalue;
    else
        isovalue = get_isovalues(R,dim,'plot',false);
    end
    
    if isscalar(options.n_digits)
        n_digits = ones(1,n_mnr) * options.n_digits;
    else
        if length(options.n_digits) ~= n_mnr
            error('n_digits must be a scalar or an array of length n_mnr')
        end
        n_digits = options.n_digits;
    end

    if isfield(options,'view')
        view_angle = options.view;
    else
        view_angle = 3;
    end

    % If style inputs are unset, make them match the substrate
    if ~isfield(options,"top_wall_color")
        options.top_wall_color = options.substrate_color;
    end
    if ~isfield(options,"top_wall_line_color")
        options.top_wall_line_color = options.substrate_line_color;
    end
    if ~isfield(options,"top_wall_line_width")
        options.top_wall_line_width = options.substrate_line_width;
    end

    % If user specified plot axis limits other than [0,1], adjust
    std_lims = [0,1;0,1;0,1];
    lims = [options.alim;options.blim;options.clim];
    if ~isequal(lims,std_lims)
        % This option is not compatible with the hex3 option, so check to
        % make sure hex3 is false
        if options.hex3
            error("cannot combine alim, blim, or clim inputs with hex3")
        end

        [R,x,y,z] = change_cell_lims(R,x,y,z,'alim',options.alim, ...
                                     'blim',options.blim, ...
                                     'clim',options.clim, ...
                                     'normalVec',normalVec);
    end
    
    resolution = options.resolution;
    hex3 = options.hex3; 
    line_width = options.line_width; 
    line_color = options.line_color;
    cb_ticks = options.cb_ticks;
    savefile = options.savefile;
    fontsize = options.fontsize;
    light_on = options.light;
    hide_axes = options.hide_axes;
    alims = options.alim;
    blims = options.blim;
    clims = options.clim;
    substrate = options.substrate;
    top_wall = options.top_wall;
    substrate_color = options.substrate_color;
    substrate_line_color = options.substrate_line_color;
    substrate_line_width = options.substrate_line_width;
    top_wall_color = options.top_wall_color;
    top_wall_line_color = options.top_wall_line_color;
    top_wall_line_width = options.top_wall_line_width;

    clear options
    
    %% Create the composition profile for each species
    for in = 1:n_mnr
        
        figure(); hold on; set(gca,'fontsize',fontsize)
        title(strcat(mono_label(in),' Block Density Profile'))

        % Plot isosurfaces, isocaps, and unit cell outlines
        if (normalVec == -1) || ((lims(normalVec+1,1) >= 0) && ...
           (lims(normalVec+1,2) <= 1))

            % This should almost always be called
            patch(isosurface(x,y,z,R(:,:,:,in),isovalue(in)), ...
                  'FaceColor',map{in}(1,:),'EdgeColor','none',...
                  'FaceAlpha',opacity(1,in));
            patch(isocaps(x,y,z,R(:,:,:,in),isovalue(in)), ...
                  'FaceColor','interp','EdgeColor','none', ...
                  'FaceAlpha',opacity(2,in));

        else 
            
            % This handles the rare case in which we need to plot multiple
            % layers of a thin film, separated by empty space. 
            unit_cells = get_cell_start_points(lims(normalVec+1,:),...
                                               grid(normalVec+1)+1);
            for i = 1:(length(unit_cells)-1)
                bds = unit_cells(i):unit_cells(i+1)-1; % unit cell bounds
                if normalVec == 0
                    patch(isosurface(x(bds,:,:),y(bds,:,:),z(bds,:,:),...
                          R(bds,:,:,in),isovalue(in)),'FaceColor',...
                          map{in}(1,:),'EdgeColor','none','FaceAlpha',...
                          opacity(1,in));
                    patch(isocaps(x(bds,:,:),y(bds,:,:),z(bds,:,:),...
                          R(bds,:,:,in),isovalue(in)),'FaceColor',...
                          'interp','EdgeColor','none','FaceAlpha',...
                          opacity(2,in));
                elseif normalVec == 1
                    patch(isosurface(x(:,bds,:),y(:,bds,:),z(:,bds,:),...
                          R(:,bds,:,in),isovalue(in)),'FaceColor',...
                          map{in}(1,:),'EdgeColor','none','FaceAlpha',...
                          opacity(1,in));
                    patch(isocaps(x(:,bds,:),y(:,bds,:),z(:,bds,:),...
                          R(:,bds,:,in),isovalue(in)),'FaceColor',...
                          'interp','EdgeColor','none','FaceAlpha',...
                          opacity(2,in));
                elseif normalVec == 2
                    patch(isosurface(x(:,:,bds),y(:,:,bds),z(:,:,bds),...
                          R(:,:,bds,in),isovalue(in)),'FaceColor',...
                          map{in}(1,:),'EdgeColor','none','FaceAlpha',...
                          opacity(1,in));
                    patch(isocaps(x(:,:,bds),y(:,:,bds),z(:,:,bds),...
                          R(:,:,bds,in),isovalue(in)),'FaceColor',...
                          'interp','EdgeColor','none','FaceAlpha',...
                          opacity(2,in));
                else
                    error("normalVec should be 0, 1, or 2");
                end

            end

        end

        draw_box(basis,'LineWidth',line_width,'EdgeColor',line_color);
        
        % Set colormap
        colormap(map{in})
        
        % We only need to show the colorbar if the isosurface intersects
        % with the faces of the unit cell. Thus, we use the data from the
        % isocaps to determine if we need to plot the colorbars.
        max_color = max(R(:,:,:,in),[],'all');
        %max_color = max(fvc.facevertexcdata);
        if isovalue(in) < max_color 
            
            % Create colorbar:
            cb_start = isovalue(in);
            cb_end = max_color;

            cblabel = round(linspace(cb_start,cb_end,cb_ticks),...
                            n_digits(in));
            tick_format = strcat('%.',string(n_digits(in)),'f');
            cblabel = compose(tick_format,cblabel');
            
            l_lngth = linspace(cb_start,cb_end,cb_ticks);
            cbh = colorbar;
            set(cbh,'ylim',[cb_start cb_end],'ytick',...
                l_lngth,'Yticklabel',cblabel,'fontsize',fontsize)

            title1 = strcat('\phi','_',mono_label(in));
            title(cbh,title1,'fontsize',fontsize*1.1)
        
        % If colorbar is not needed, we opt instead to add a text box
        % indicating the value of the isovalue we are showing.
        else

            % Creating the label for the isovalue(in)
            text_disp = strcat('\phi','_',mono_label(in),'=',...
                               num2str(round(isovalue(in),n_digits(in)))); 

            % Setting the location for the label
            text(x(grid(1)+1,1,round(grid(3)/2)), ...
                 y(grid(1)+1,1,round(grid(3)/2)), ...
                 z(grid(1)+1,1,round(grid(3)/2)),...
                 text_disp,'color',map{in}(end,:),'fontsize',fontsize+4)
             
        end
        
        % If hex3 == true, we plot two more unit cells rotated by 120° and
        % 240° around the z-axis, which is a common way to visualize
        % hexagonal unit cells. 
        if hex3
            
            for rotation = [120,240] % Angle of rotation, in degrees
                
                % Create rotation matrix to apply to our data coordinates
                rot_matrix = [ cosd(rotation), sind(rotation), 0;
                              -sind(rotation), cosd(rotation), 0;
                                            0,              0, 1];

                % Put x, y, and z data into a 2D array coord_set, where
                % each row represents the coordinates of one data point.
                % This allows us to apply the rotation matrix to our data
                size_grid = (grid(1)+1)*(grid(2)+1)*(grid(3)+1);
                coord_set = zeros(size_grid,3);
                counter = 0;
                
                for iz = 1:grid(3)+1
                    for iy = 1:grid(2)+1
                        for ix = 1:grid(1)+1
                            counter = counter +1;
                            coord_set(counter,1) = x(ix,iy,iz);
                            coord_set(counter,2) = y(ix,iy,iz);
                            coord_set(counter,3) = z(ix,iy,iz);
                        end
                    end
                end

                % Apply rotation matrix to data
                coord_set = coord_set*rot_matrix;
                
                % Put data back into 3D arrays x2, y2, and z2 for plotting
                counter = 0;
                x2 = zeros(size(x));
                y2 = zeros(size(y));
                z2 = zeros(size(z));
                for iz = 1:grid(3)+1
                    for iy = 1:grid(2)+1
                        for ix = 1:grid(1)+1
                            counter = counter +1;
                            x2(ix,iy,iz) = coord_set(counter,1) ;
                            y2(ix,iy,iz) = coord_set(counter,2) ;
                            z2(ix,iy,iz) = coord_set(counter,3) ;
                        end
                    end
                end
                clear coord_set

                % Plot the isosurface, isocaps, and unit cell outline for 
                % the rotated unit cell
                patch(isosurface(x2,y2,z2,R(:,:,:,in),isovalue(in)), ...
                      'FaceColor',map{in}(1,:),'EdgeColor','none', ...
                      'FaceAlpha',opacity(1,in));
                patch(isocaps(x2,y2,z2,R(:,:,:,in),isovalue(in)), ...
                      'FaceColor','interp','EdgeColor','none', ...
                      'FaceAlpha',opacity(2,in));
                basis_2 = basis * rot_matrix; % rotated basis vecs
                draw_box(basis_2,'LineWidth',line_width,...
                         'EdgeColor',line_color);

            end
        end

        % If a substrate and/or top wall are included, draw them
    if substrate || top_wall

        if (basis(1,3) > 1e-8) || (basis(2,3) > 1e-8)
            error("a and b basis vectors must be in the x-y plane")
        end
        
        % Setup
        box_basis = zeros(3,3);
        origin = [0,0,0];
        sc = 0.05; % scale factor determining how much wider the substrate
                   % and top wall are than the actual polymer unit cell

        xd = alims(2)-alims(1);
        yd = blims(2)-blims(1);
        zd = clims(2)-clims(1);
        box_basis(1,1) = (1+sc) * ((xd * basis(1,1)) + ...
                         (yd * abs(basis(2,1)) + (zd * abs(basis(3,1)))));
        box_basis(2,2) = (1+sc) * ((xd * basis(1,2)) + ...
                         (yd * abs(basis(2,2)) + (zd * abs(basis(3,2)))));
        if normalVec == -1 % not a thin film system
            box_basis(3,3) = sc * zd * basis(3,3);
        else
            box_basis(3,3) = min(z,[],'all');
        end
        
        origin(1) = min(x,[],'all') - ((sc/2) * xd * basis(1,1));
        origin(2) = min(y,[],'all') - ((sc/2) * yd * basis(2,2));
        
        if substrate
            % Draw substrate graphic
            origin(3) = min(z,[],'all')  - box_basis(3,3);
            draw_box(box_basis,origin,...
                     "FaceColor",substrate_color,...
                     "EdgeColor",substrate_line_color,...
                     "LineWidth",substrate_line_width);
        end

        if top_wall
            % Draw top wall graphic
            origin(3) = max(z,[],'all');
            draw_box(box_basis,origin,...
                     "FaceColor",top_wall_color,...
                     "EdgeColor",top_wall_line_color,...
                     "LineWidth",top_wall_line_width);
        end

    end

        view(view_angle); % Sets viewing angle

        % Fix data aspect ratio and set axis limits to "tight" setting
        daspect([1 1 1]);  % Equates the data aspect ratio for each axis
        axis tight;        % Snaps the axis to the data set
    
        % If thin film, extend axis limits to unit cell boundary
        if normalVec == 0
            xlim(alims*sum(basis(:,1)));
        elseif normalVec == 1
            ylim(blims*sum(basis(:,2)));
        elseif normalVec == 2
            zlim(clims*sum(basis(:,3)));
        end
        
        % Set aspect ratio of the axes to be equal to that of the plot
        pb = pbaspect; % Plot box aspect ratio
        [az,el] = view(); % viewing angle
        aspect_ratio = get_aspect_ratio(az,el,pb); % aspect ratio of plot
        set(gca,'Units','Points'); % Fixed units rather than reduced units
        ax_pos = get(gca,'Position');
        ax_pos(3) = ax_pos(4) * aspect_ratio;
        set(gca,'Position',ax_pos);

        set(cbh,'Units','Points'); % Fixed units rather than reduced 
        set(gcf,'Units','Points');
        
        if isovalue(in) < max_color % If we have a colorbar
            
            % Estimate the width of our ticklabels
            [~,ind] = max(strlength(cblabel)); %Find longest ticklabel
            tmp = text(0,0,0,cblabel(ind),'fontsize',fontsize); 
            set(tmp,"Units","Points");
            txt_extent = get(tmp,"Extent"); % Find width of the text
            txt_width = txt_extent(3);
            delete(tmp) % Delete the temporary text we plotted

            % Update figure size to fit everything on the figure
            cb_pos = get(cbh,'Position');
            fig_pos = get(gcf,'position');
            % Make figure wide enough to see colorbar
            fig_pos(3) = (cb_pos(1) + cb_pos(3)) + txt_width + 40;
            % Make figure taller to fit cb titles
            fig_pos(4) = fig_pos(4) + (fontsize*1.1); 
            set(gcf,'position',fig_pos);
            
        else
            
            % Make figure a little taller, just for aesthetics
            fig_pos = get(gcf,'position');
            fig_pos(4) = fig_pos(4) + (fontsize*1.1);
            set(gcf,'position',fig_pos);
            
        end

        % Return to default units for all graphics objects
        drawnow % this refreshes all graphics objects (processes callbacks)
        set(gca,'Units','Normalized')
        set(gcf,'Units','Normalized')
        set(cbh,'Units','Normalized','Location','Manual')

        % Add light if desired
        if light_on
            light('position',[-1 -1 1]);
            lighting gouraud;
        end
    
        % Hide axes if desired
        if hide_axes
            set(gca,'visible','off')
        end

        % Save figure if a filename is provided
        if savefile ~= ""
            [f_path,f_name,ext] = fileparts(savefile);
            save_filename = fullfile(f_path, ...
                                strcat(f_name,mono_label(in),ext));
            if (ext == ".fig") || (ext == ".m")
                saveas(gcf,save_filename);
            else
                if ext == ".jpg"
                    format = "-djpeg";
                elseif ext == ".tif"
                    format = "-dtiff";
                else
                    format = strcat("-d", extractAfter(ext,1));
                end
                res = strcat("-r",num2str(resolution));
                print(gcf,save_filename,format,res);
            end
        end
        
        % Prep figure for interactive use
        rotate3d on

        drawnow
        hold off

    end
end
