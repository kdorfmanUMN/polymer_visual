function contour_plot(R,contourvecs,basis,options)

    arguments
        
        % The first parameter of this function, R, is "overloaded". This
        % means that the function accepts either a string or a data array 
        % for the first parameter, and it will work correctly either way. 
        
        % If the first parameter is a string, we assume it is a filename
        % that contains the data we wish to plot. Thus, we will use
        % read_rgrid.m to collect the data that will be plotted.
        
        % If the first parameter is instead a data array, it must contain
        % all of the composition data stored in the rgrid file. For an
        % N-dimensional system, R must be an (N+1)-dimensional array. In
        % 3D, R(i,j,k,l) gives the composition of species l at gridpoint
        % (i,j,k). 
        R

        % contourvecs is an array with 3 rows: the first row defines the
        % gridpoint corresponding to the lower-left corner of the contour 
        % plot in reduced coordinates (error will occur if this is not on a
        % gridpoint). The second row is a vector defining the direction and
        % magnitude of the x-axis of the contour plot. The third row is the
        % same but for the y-axis. If the angle between these two vectors
        % is not 90Â°, the function will automatically impose a slant to the
        % contour plot. This is a required input.
        contourvecs
        
        % If R is a data array rather than a filename, then basis must also
        % be provided. The default value (empty arrays) below is provided 
        % only because this input is not required if R is a filename

        % basis is a required input array where each row is a lattice basis
        % vector in Cartesian coordinates (see get_basis.m). Thus, in 3D
        % this needs to be a 3x3 array.
        basis = [];
        
        % ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        % The rest of the inputs are optional name-value pair inputs:

        % savefile is a filename to which the figures will be saved.
        % The file extension provided (e.g. ".fig" or ".png") will be used
        % to determine the type of file to save. Since this function
        % typically generates more than 1 figure, we append mono_label(i)
        % to the end of the filename when saving the composition profile
        % for species i. If left empty (which is the default behavior), the
        % figures are not saved.
        options.savefile = "";

        % fontsize specifies the FontSize parameter for the axis on which
        % data are plotted. Default value is 10.
        options.fontsize = 14;
        
        % mono_label contains labels for each monomer species. If not
        % specified, we use ["A","B","C",...] as the default behavior.
        options.mono_label = ["A","B","C","D","E","F","G","H"];
                
        % map is a cell array containing a colormap for each species.
        % map{i} is the colormap for species i. If unspecified, we use the
        % default colormaps generated by get_colormaps.m.
        options.map

        % isovalue is an array of isovalues representing the minimum volume
        % fraction to show on plot. One for each species. If not specified,
        % we call get_isovalues.m to calculate them automatically.
        options.isovalue

        % cb_ticks is the number of ticks on the colorbar, default is 10.
        options.cb_ticks = 10;
        
        % cb_rows defines the number of rows of colorbars that are
        % shown on the figure. For example, if there are 8 colorbars on the
        % figure, cb_rows = 2 will result in a 2x4 grid of colorbars
        % being shown on the figure, as opposed to the default 1x8 grid.
        options.cb_rows = 1;

        % n_digits is the number of digits past the decimal point to use
        % for the colorbar tick labels. Can be specified as a scalar, or as
        % an array of length n_mnr (one value per monomer species plotted)
        % if you want a different # of digits for each colorbar. Default is
        % 3.
        options.n_digits = 3;

        % phase is a string containing the name of the phase being plotted.
        % This is used to plot the voronoi partition between particle
        % sites on the 2D contour plot, based on hard-coded particle sites
        % that are listed in utilities/get_atomloc.m. If the phase name is
        % provided but does not match any in get_atomloc, an error will
        % occur. 
        options.phase = "";

        % If your SCFT result is a thin film, you should include
        % film_params as an input to apply a thin film correction.
        %
        % film_params is an array with 4 entries. The first 3 entries
        % correspond to the 3 required parameters in pscfpp that are needed
        % to define a Wall object: normalVec, interfaceThickness, and
        % wallThickness. See pscfpp documentation for details about what
        % each of these three parameters means. The fourth entry is a
        % boolean (i.e. 0 for false, 1 for true) that indicates whether or
        % not to rotate the figure to make the z axis orthogonal to the
        % wall. If this film_params input is included, the code will apply
        % a correction to the plot to make the figure look good as a thin
        % film. If it is not included, it is assumed that the data being
        % plotted are not under a thin film constraint.
        %
        % This input only affects the resulting plot if the input R is a
        % filename, not a dataset. If R is a dataset, it is assumed that
        % any desired corrections (e.g. the thin film correction) have
        % already been applied.
        options.film_params;
        
    end
    
    savefile = options.savefile;     fontsize = options.fontsize;
    mono_label = options.mono_label; cb_ticks = options.cb_ticks;
    cb_rows = options.cb_rows;       phase = options.phase;           

    % Ensure that the code below can access our utilities
    [filepath,~,~] = fileparts(mfilename('fullpath'));
    addpath(filepath+"/utilities")

    % if a filename is passed to the function, read data from that file
    if ischar(R) || isstring(R) 
        
        close all; % close other figures
                
        % Read data from file
        [R,x,y,z,dim,~,cell_d,angle,n_mnr,grid] = read_rgrid(R);
        
        % Get lattice basis vectors
        basis = get_basis(cell_d,angle);

        % Apply thin film correction if desired
        if isfield(options,'film_params') && ~isempty(options.film_params)
            R = thin_film_correction(R,x,y,z,basis,...
                          options.film_params(1),options.film_params(2),...
                          options.film_params(3),options.film_params(4));
        end
    
    % If R is not a string defining a filename, we assume it is a data
    % array containing species compositions. So, below we make sure we have
    % all of the other data we need to proceed, and define some useful
    % variables.
    else
        
        % Make sure that basis array is provided
        if isempty(basis) % if basis array is not provided
            error("basis must both be provided as input")
        end
        
        grid = size(R); grid = grid(1:size(basis,2));
        dim = length(grid);
        
        % Define grid and n_mnr (defined differently in 2D vs 3D)
        if dim == 3
            grid = [size(R,1)-1,size(R,2)-1,size(R,3)-1];
            n_mnr = size(R,4);
        elseif dim == 2
            n_mnr = size(R,3);
            grid = [size(R,1)-1,size(R,2)-1];
        else
            error('dim should be 2 or 3')
        end
        
    end

    if isfield(options,'map')
        map = options.map;
    else
        map = get_colormaps();
    end
    
    if isfield(options,'isovalue')
        isovalue = options.isovalue;
    else
        isovalue = get_isovalues(R,dim,n_mnr,grid,'plot',false);
    end
    
    if isscalar(options.n_digits)
        n_digits = ones(1,n_mnr) * options.n_digits;
    else
        if length(options.n_digits) ~= n_mnr
            error('n_digits must be a scalar or an array of length n_mnr')
        end
        n_digits = options.n_digits;
    end

    clear options;

    max_comps = zeros(1,n_mnr);
    for in = 1:n_mnr
        max_comps(in) = max(max(max(R(:,:,:,in))));
    end

    startloc = contourvecs(1,:); % Starting coordinates
    xvec = contourvecs(2,:);     % x-axis vector in reduced coords
    yvec = contourvecs(3,:);     % y-axis vector in reduced coords

    % Find angle between xvec and yvec by making two new vectors, xvec_orth
    % and yvec_orth that are defined in cartesian coordinates
    xvec_orth = zeros(1,size(basis,2));
    yvec_orth = zeros(1,size(basis,2));
    for row = 1:size(basis,2)
        xvec_orth = xvec_orth + (xvec(row) * basis(row,:));
        yvec_orth = yvec_orth + (yvec(row) * basis(row,:));
    end
    cos_theta = dot(xvec_orth,yvec_orth)/(norm(xvec_orth)*norm(yvec_orth));
    theta = acos(cos_theta); % angle between xvec and yvec in radians
    
    % Convert vectors to grid coordinates
    start_coord = startloc .* grid + [1 1 1];
    if ~isequal(start_coord,round(start_coord,0))
        disp('Starting coordinates:')
        disp(start_coord)
        error('Starting coordinates are not on a gridpoint')
    end

    xvec_coord = xvec .* grid;
    yvec_coord = yvec .* grid;
    x_step_length = max(abs(xvec_coord));
    y_step_length = max(abs(yvec_coord));
    x_init = linspace(0,norm(xvec_orth),x_step_length);
    y_init = linspace(0,norm(yvec_orth),y_step_length);

    % Find gridpoints & their data vals in the plane of the contour plot
    contour_data = zeros(y_step_length,x_step_length,n_mnr);
    xcontour = zeros(y_step_length,x_step_length);
    ycontour = zeros(y_step_length,x_step_length);
    for xval = 1:x_step_length
        for yval = 1:y_step_length

            x_coord = start_coord(1) + ...
                      (xval-1)*(xvec_coord(1)/x_step_length) + ...
                      (yval-1)*(yvec_coord(1)/y_step_length);
            x_coord = fit_in_cell(x_coord,grid(1));

            y_coord = start_coord(2) + ...
                      (xval-1)*(xvec_coord(2)/x_step_length) + ...
                      (yval-1)*(yvec_coord(2)/y_step_length);
            y_coord = fit_in_cell(y_coord,grid(2));

            z_coord = start_coord(3) + ...
                      (xval-1)*(xvec_coord(3)/x_step_length) + ...
                      (yval-1)*(yvec_coord(3)/y_step_length);
            z_coord = fit_in_cell(z_coord,grid(3));

            if isequal(round([x_coord y_coord z_coord],2),...
                       round([x_coord y_coord z_coord],0))
                contour_data(yval,xval,1:n_mnr) = R(x_coord,y_coord,...
                                                    z_coord,1:n_mnr);
            else
                contour_data(yval,xval,1:n_mnr) = nan;
            end

            xcontour(yval,xval) = x_init(xval)+(y_init(yval).*cos(theta));
            ycontour(yval,xval) = y_init(yval).*sin(theta);
        end
    end

    % Delete rows/columns if the whole row/column is NaN, because this
    % affects the interpolation of contourf:
    xvals_to_delete = [];
    yvals_to_delete = [];
    for xval = 1:x_step_length
        if isequal(isnan(contour_data(:,xval,1)),...
                   ones(size(contour_data(:,xval,1))))
            xvals_to_delete(end+1) = xval; %#ok<*AGROW> 
        end
    end

    for yval = 1:y_step_length
        if isequal(isnan(contour_data(yval,:,1)),...
                   ones(size(contour_data(yval,:,1))))
            yvals_to_delete(end+1) = yval;
        end
    end

    contour_data(:,xvals_to_delete,:) = [];
    contour_data(yvals_to_delete,:,:) = [];
    xcontour(:,xvals_to_delete,:) = [];
    xcontour(yvals_to_delete,:,:) = [];
    ycontour(:,xvals_to_delete,:) = [];
    ycontour(yvals_to_delete,:,:) = [];

    
    % Make contour plot
    figure(); hold on; 
    
    for in = 1:n_mnr
        
        contour_colors = linspace(isovalue(in),max_comps(in),50);
        cblabel = linspace(isovalue(in),max_comps(in),cb_ticks);
        tick_format = strcat('%.',string(n_digits(in)),'f');
        cblabel = compose(tick_format,cblabel');
        ticks = linspace(isovalue(in),max_comps(in),cb_ticks);
        
        if in == 1
            ax(in) = gca;
        else
            ax(in) = axes;
        end
        set(gca,'fontsize',fontsize)

        contourf(xcontour,ycontour,contour_data(:,:,in),contour_colors,...
                 'linecolor','none')
        colormap(gca,map{in})
        cb(in) = colorbar(gca);
        set(cb(in),'ytick',ticks,'Yticklabel',cblabel)
        caxis(ax(in),[isovalue(in),max_comps(in)])
        title1 = strcat('\phi','_',mono_label(in));
        title(cb(in),title1,'fontsize',fontsize*1.1)

        set(ax(in),'Visible','off');
        daspect([1 1 1])
        if in==1
            pb = pbaspect;
            ax_pos = [72.8,46.2,342.3*pb(1)/pb(2),342.3];
        end
        set(gca,'units','points','position',ax_pos);
    end
    
    % Set up for the case of multiple rows of colorbars
    ncol = ceil(n_mnr/cb_rows);
    if cb_rows > 1 % If we need to calculate positions of multiple cb rows
        
        % See how tall the colorbar title is
        title1 = strcat('\phi','_',mono_label(1));
        tmp = text(0,0,0,title1,'fontsize',fontsize*1.1); % Plot the text
        set(tmp,"Units","Points");
        txt_height = get(tmp,"Extent"); % Find height of the text box
        txt_height = txt_height(4);
        delete(tmp) % Delete the temporary text we plotted
        
        % Get variables needed to determine colorbar positions
        title_h = txt_height * 1.3 + 10; % Space allocated for cb titles
        total_h = ax_pos(4); % Total height of each column
        top_pos = ax_pos(4)+ax_pos(2); % coordinate of top edge of column
        cb_space = total_h - (title_h * (cb_rows-1)); 
        rows = 1:cb_rows;
        
        % construct cb_y, a list of the y-coordinates of the colorbars in
        % each row. cb_y(r) is the y-coord of the colorbar in row r.
        cb_h = cb_space / cb_rows; % height of all colorbars
        cb_y = top_pos - (rows*cb_h) - ((rows-1)*title_h); 
        
    else % Only 1 colorbar row, use default height
        
        cb_y = ones(n_mnr,1) * ax_pos(2); % y coord of each colorbar
        cb_h = ax_pos(4); % height of each colorbar
        
    end
    
    cb_x = ax_pos(1)+ax_pos(3)+40; 
    
    for col = 1:ncol
        txt_width = 0;
        for row = 1:cb_rows
            % Monomer index for this row/column
            in = (row-1)*ncol + col; 
            if in <= n_mnr % If this column/row should contain a colorbar:

                % Create the colorbar
                cb_pos = [cb_x,cb_y(row),22,cb_h];
                set(cb(in),"axislocation","out","Units","Points",...
                    "fontsize",fontsize,"Position",cb_pos,"color","k");
                
                % Estimate the width of our ticklabels, and if it is larger
                % than txt_width then update txt_width
                [~,ind] = max(strlength(cblabel)); %Find longest ticklabel
                tmp = text(0,0,0,cblabel(ind),'fontsize',fontsize); 
                set(tmp,"Units","Points");
                txt_extent = get(tmp,"Extent"); % Find width of the text
                if txt_extent(3) > txt_width % Update txt_width if needed
                    txt_width = txt_extent(3);
                end
                delete(tmp) % Delete the temporary text we plotted
                
            end
        end
        
        % Update colorbar x-position for the next row
        cb_x = cb_x + 22 + txt_width + 20; 
        
    end
    
    if phase ~= "" % If phase is specified, draw voronoi partition
        
        xlims = xlim; ylims = ylim;
        
        % Find voronoi cells and boundaries for this crystal
        % structure (all in terms of miller indices!)
        [v,c] = get_voronoi(basis,phase);
        n_voro = length(c);
        
        % find lines of voronoi cells intersecting with the plotting plane
        hold on
        for i_vor = 1:n_voro
            ptcloud = v(c{i_vor},:); % corners of voronoi cell

            if any(ptcloud==Inf)
                continue
            end
            P = get_cross_section(ptcloud,startloc,cross(xvec,yvec));
            if isempty(P)
                continue
            end
            % find linear combination of plane vectors required to get to 
            % these points
            rescaled = ([xvec; yvec]'\P')';
            k = convhull(rescaled);
            plot(rescaled(k,1)*norm(xvec),rescaled(k,2)*norm(yvec),'k-','linewidth',2)
            xlim(xlims); ylim(ylims);
        end
        
    end
    
    % Update figure size to show everything we want to show
    set(gcf,'Units','Points');
    fig_pos = get(gcf,'position');
    fig_pos(3) = cb_x * 1.05; % Make figure wide enough to see all cbs
    % Make figure taller to fit cb titles
    fig_pos(4) = fig_pos(4) + (fontsize*1.1); 
    set(gcf,'position',fig_pos);
    
    % Save figure if a filename is provided
    if savefile ~= ""
        saveas(gcf,savefile);
    end
    
    hold off

end
