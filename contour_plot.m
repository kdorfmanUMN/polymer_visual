function contour_plot(R,contourvecs,basis,options)

    arguments
        
        % The first parameter of this function, R, is "overloaded". This
        % means that the function accepts either a string or a data array 
        % for the first parameter, and it will work correctly either way. 
        
        % If the first parameter is a string, we assume it is a filename
        % that contains the data we wish to plot. Thus, we will use
        % read_rgrid.m to collect the data that will be plotted.
        
        % If the first parameter is instead a data array, it must contain
        % all of the composition data stored in the rgrid file. For an
        % N-dimensional system, R must be an (N+1)-dimensional array. In
        % 3D, R(i,j,k,l) gives the composition of species l at gridpoint
        % (i,j,k). 
        R

        % contourvecs is an array with 3 rows: the first row defines the
        % gridpoint corresponding to the lower-left corner of the contour 
        % plot in reduced coordinates (error will occur if this is not on a
        % gridpoint). The second row is a vector defining the direction and
        % magnitude of the x-axis of the contour plot. The third row is the
        % same but for the y-axis. If the angle between these two vectors
        % is not 90Â°, the function will automatically impose a slant to the
        % contour plot. This is a required input.
        contourvecs
        
        % If R is a data array rather than a filename, then basis must also
        % be provided. The default value (empty arrays) below is provided 
        % only because this input is not required if R is a filename

        % basis is a required input array where each row is a lattice basis
        % vector in Cartesian coordinates (see get_basis.m). Thus, in 3D
        % this needs to be a 3x3 array.
        basis = [];
        
        % ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        % The rest of the inputs are optional name-value pair inputs:

        % savefile is a filename to which the figures will be saved.
        % The file extension provided (e.g. ".fig" or ".png") will be used
        % to determine the type of file to save. Since this function
        % typically generates more than 1 figure, we append mono_label(i)
        % to the end of the filename when saving the composition profile
        % for species i. If left empty (which is the default behavior), the
        % figures are not saved.
        options.savefile = "";

        % fontsize specifies the FontSize parameter for the axis on which
        % data are plotted. Default value is 10.
        options.fontsize = 14;
        
        % mono_label contains labels for each monomer species. If not
        % specified, we use ["A","B","C",...] as the default behavior.
        options.mono_label = ["A","B","C","D","E","F","G","H"];
                
        % map is a cell array containing a colormap for each species.
        % map{i} is the colormap for species i. If unspecified, we use the
        % default colormaps generated by get_colormaps.m.
        options.map

        % isovalue is an array of isovalues representing the minimum volume
        % fraction to show on plot. One for each species. If not specified,
        % we call get_isovalues.m to calculate them automatically.
        options.isovalue

        % cb_ticks is the number of ticks on the colorbar, default is 10.
        options.cb_ticks = 10;
        
        % cb_rows defines the number of rows of colorbars that are
        % shown on the figure. For example, if there are 8 colorbars on the
        % figure, cb_rows = 2 will result in a 2x4 grid of colorbars
        % being shown on the figure, as opposed to the default 1x8 grid.
        options.cb_rows = 1;

        % n_digits is the number of digits past the decimal point to use
        % for the colorbar tick labels. Can be specified as a scalar, or as
        % an array of length n_mnr (one value per monomer species plotted)
        % if you want a different # of digits for each colorbar. Default is
        % 3.
        options.n_digits = 3;

        % phase is a string containing the name of the phase being plotted.
        % This is used to plot the voronoi partition between particle
        % sites on the 2D contour plot, based on hard-coded particle sites
        % that are listed in utilities/get_atomloc.m. If the phase name is
        % provided but does not match any in get_atomloc, an error will
        % occur. 
        options.phase = "";
        
    end
    
    savefile = options.savefile;     fontsize = options.fontsize;
    mono_label = options.mono_label; cb_ticks = options.cb_ticks;
    cb_rows = options.cb_rows;       n_digits = options.n_digits;
    phase = options.phase;           

    % Ensure that the code below can access our utilities
    addpath(pwd+"/utilities")
    
    % if a filename is passed to the function, read data from that file
    if ischar(R) || isstring(R) 
        
        close all; % close other figures
                
        % Read data from file
        [R,~,~,~,dim,~,cell_d,angle,n_mnr,grid] = read_rgrid(R);
        
        % Get lattice basis vectors
        basis = get_basis(cell_d,angle);
    
    % If R is not a string defining a filename, we assume it is a data
    % array containing species compositions. So, below we make sure we have
    % all of the other data we need to proceed, and define some useful
    % variables.
    else
        
        % Make sure that basis array is provided
        if isempty(basis) % if basis array is not provided
            error("basis must both be provided as input")
        end
        
        grid = size(R); grid = grid(1:size(basis,2));
        dim = length(grid);
        
        % Define grid, basis, and n_mnr (defined differently in 2D vs 3D)
        if dim == 3
            grid = [size(R,1)-1,size(R,2)-1,size(R,3)-1];
            n_mnr = size(R,4);
            basis = [x(end,1,1),y(end,1,1),z(end,1,1);
                     x(1,end,1),y(1,end,1),z(1,end,1);
                     x(1,1,end),y(1,1,end),z(1,1,end);];
        elseif dim == 2
            n_mnr = size(R,3);
            basis = [x(end,1), y(end,1); x(1,end), y(1,end)];
            if options.make_3d
                grid = [size(R,1)-1,size(R,2)-1,10];
                
                % use the make_3d function to expand the 2D data into a
                % third dimension with z-height equal to the average length
                % of the two lattice basis vectors
                height = (norm(basis(1,:)) + norm(basis(2,:))) / 2;
                [R,x,y,z] = make_3d(R,x,y,height);
                basis = [basis(1,1), basis(1,2), 0;
                         basis(2,1), basis(2,2), 0;
                         0,          0,          height];
            else
                grid = [size(R,1)-1,size(R,2)-1];
            end
        else
            error("x array should be either 2 or 3 dimensions")
        end
        
    end

    if isfield(options,'map')
        map = options.map;
    else
        map = get_colormaps();
    end
    
    if isfield(options,'isovalue')
        isovalue = options.isovalue;
    else
        isovalue = get_isovalues(R,dim,n_mnr,grid,'linedraw',false);
    end

    clear options;

    max_comps = zeros(1,n_mnr);
    for in = 1:n_mnr
        max_comps(in) = max(max(max(R(:,:,:,in))));
    end

    startloc = contourvecs(1,:); % Starting coordinates
    xvec = contourvecs(2,:);     % x-axis vector in reduced coords
    yvec = contourvecs(3,:);     % y-axis vector in reduced coords

    % Find angle between xvec and yvec by making two new vectors, xvec_orth
    % and yvec_orth that are defined in cartesian coordinates
    xvec_orth = zeros(1,size(basis,2));
    yvec_orth = zeros(1,size(basis,2));
    for row = 1:size(basis,2)
        xvec_orth = xvec_orth + (xvec(row) * basis(row,:));
        yvec_orth = yvec_orth + (yvec(row) * basis(row,:));
    end
    cos_theta = dot(xvec_orth,yvec_orth)/(norm(xvec_orth)*norm(yvec_orth));
    theta = acos(cos_theta); % angle between xvec and yvec in radians

    % Convert vectors to grid coordinates
    start_coord = startloc .* grid + [1 1 1];
    if ~isequal(start_coord,round(start_coord,0))
        disp('Starting coordinates:')
        disp(start_coord)
        error('Starting coordinates are not on a gridpoint')
    end

    xvec_coord = xvec .* grid;
    yvec_coord = yvec .* grid;
    x_step_length = max(abs(xvec_coord));
    y_step_length = max(abs(yvec_coord));
    x_init = linspace(0,norm(xvec),x_step_length);
    y_init = linspace(0,norm(yvec),y_step_length);

    % Find gridpoints & their data vals in the plane of the contour plot
    contour_data = zeros(y_step_length,x_step_length,n_mnr);
    xcontour = zeros(y_step_length,x_step_length);
    ycontour = zeros(y_step_length,x_step_length);
    for xval = 1:x_step_length
        for yval = 1:y_step_length

            x_coord = start_coord(1) + ...
                      (xval-1)*(xvec_coord(1)/x_step_length) + ...
                      (yval-1)*(yvec_coord(1)/y_step_length);
            x_coord = fit_in_cell(x_coord,grid(1));

            y_coord = start_coord(2) + ...
                      (xval-1)*(xvec_coord(2)/x_step_length) + ...
                      (yval-1)*(yvec_coord(2)/y_step_length);
            y_coord = fit_in_cell(y_coord,grid(2));

            z_coord = start_coord(3) + ...
                      (xval-1)*(xvec_coord(3)/x_step_length) + ...
                      (yval-1)*(yvec_coord(3)/y_step_length);
            z_coord = fit_in_cell(z_coord,grid(3));

            if isequal(round([x_coord y_coord z_coord],2),round([x_coord y_coord z_coord],0))
                contour_data(yval,xval,1:n_mnr) = R(x_coord,y_coord,z_coord,1:n_mnr);
            else
                contour_data(yval,xval,1:n_mnr) = nan;
            end

            xcontour(yval,xval) = x_init(xval) + (y_init(yval).*cos(theta));
            ycontour(yval,xval) = y_init(yval).*sin(theta);
        end
    end

    % Delete rows/columns if the whole row/column is NaN, because this
    % affects the interpolation of contourf:
    xvals_to_delete = [];
    yvals_to_delete = [];
    for xval = 1:x_step_length
        if isequal(isnan(contour_data(:,xval,1)),ones(size(contour_data(:,xval,1))))
            xvals_to_delete(end+1) = xval; %#ok<*AGROW> 
        end
    end

    for yval = 1:y_step_length
        if isequal(isnan(contour_data(yval,:,1)),ones(size(contour_data(yval,:,1))))
            yvals_to_delete(end+1) = yval;
        end
    end

    contour_data(:,xvals_to_delete,:) = [];
    contour_data(yvals_to_delete,:,:) = [];
    xcontour(:,xvals_to_delete,:) = [];
    xcontour(yvals_to_delete,:,:) = [];
    ycontour(:,xvals_to_delete,:) = [];
    ycontour(yvals_to_delete,:,:) = [];

    
    % Make contour plot
    cblabel2 = zeros(n_mnr,50); 
    cblabel3 = zeros(n_mnr,cb_ticks);
    
    figure(); hold on; 
    
    for in = 1:n_mnr
        cblabel2(in,:) = round(linspace(isovalue(in),max_comps(in),50),3);
        cblabel3(in,:) = round(linspace(isovalue(in),max_comps(in),...
                               cb_ticks),3);

        if in == 1
            ax(in) = gca;
        else
            ax(in) = axes;
        end

        contourf(xcontour,ycontour,contour_data(:,:,in),cblabel2(in,:),'linecolor','none')
        colormap(gca,map{in})
        %cb(in) = colorbar(gca);
        %set(cb(in),'ytick',cblabel3(in,:),'Yticklabel',cblabel3(in,:))
        %caxis([min(cblabel3(in,:)),max(cblabel3(in,:))])
        %title1 = strcat('\phi','_',mono_label(in));
        %title(cb(in),title1,'fontsize',20)

        set(ax(in),'Visible','off');
        %daspect([1 1 1])
        
    end
    %set(gcf,'position',[100 100 1200 600]) % 1625 is good on long axis for hexagonal plots
    
    if phase ~= "" % If phase is specified, draw voronoi partition
        
        % Find voronoi cells and boundaries for this crystal
        % structure (all in terms of miller indices!)
        [v,c] = get_voronoi(cell_d,angle,phase);
        n_voro = length(c);
        
        % find lines of voronoi cells intersecting with the plotting plane
        hold on
        for i_vor = 1:n_voro
            ptcloud = v(c{i_vor},:); % corners of voronoi cell

            if any(ptcloud==Inf)
                continue
            end
            P = get_cross_section(ptcloud,startloc,cross(xvec,yvec));
            if isempty(P)
                continue
            end
            % find linear combination of plane vectors required to get to these
            % points
            rescaled = ([xvec; yvec]'\P')';
            k = convhull(rescaled);
            plot(rescaled(k,1),rescaled(k,2),'k-','linewidth',2)
        end
        
    end

    hold off

end